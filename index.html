<title>He Is Coming √¢‚Ç¨‚Äù Loadout Builder (v5)</title>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<style>
html,body { margin:0; height:100%; background:#000; color:#f33; font-family: Inter, system-ui, Arial, sans-serif; }
/* Slightly smaller font for a more compact UI */
html { font-size:13px; }
header { padding:10px 16px; border-bottom:2px solid #f33; }
.frame {
  display: grid;
  grid-template-columns: 300px minmax(0, 1fr) 300px;
  gap: 6px;
  height: calc(100vh - 52px);
  padding: 6px;
  overflow: hidden;
}
.panel {
  background:#000;
  border:2px solid #f33;
  border-radius:10px;
  padding:6px;
  display:flex;
  flex-direction:column;
  min-height:0;
  overflow:auto; /* allow column to scroll instead of page */
}
.title { font-size:12px; color:#f33; margin:4px 2px 6px; }
.oils { display:flex; flex-direction:column; gap:6px; }
.oil { display:flex; align-items:center; gap:8px; border:2px solid #f33; border-radius:8px; padding:6px; cursor:pointer; }
.oil img { width:22px; height:22px; image-rendering:pixelated; }
.oil.active { background:#300; }
.weapon-slot { border:2px dashed #f33; border-radius:10px; padding:8px; text-align:center; margin:8px 0; min-height:48px; display:flex; align-items:center; justify-content:center; }
.grid12 {
  display:grid;
  grid-template-columns: repeat(2, 1fr);
  grid-auto-rows: 60px;
  gap:6px;
  flex:1;
}
.slot { border:2px dashed #f33; border-radius:10px; display:flex; align-items:center; justify-content:center; color:#f33; }
.slot.filled { border-style:solid; }
.slot img { width:40px; height:40px; image-rendering:pixelated; }
.weapon-slot img { width:48px; height:48px; image-rendering:pixelated; }
.edge-tile { border:2px solid #f33; border-radius:10px; padding:6px; display:flex; flex-direction:column; gap:6px; margin-bottom:8px; }
.edge-body { display:flex; align-items:center; gap:8px; }
.edge-body img { width:20px; height:20px; image-rendering:pixelated; }
.edge-tile select { flex:1; background:#000; color:#f33; border:1px solid #f33; border-radius:6px; padding:4px 6px; }
.stats { display:flex; flex-direction: column; align-items:flex-start; gap:6px; padding-top:8px; border-top:2px solid #f33; }
.stat {
  display: flex;
  align-items: center;
  gap: 10px;
  background: #2f5d1a;
  border: 2px solid #95d5b2;
  border-radius: 999px;
  padding: 8px 18px;
  font-size: 20px;
  color: #fff;
  font-weight: bold;
  box-shadow: 0 2px 8px rgba(149,213,178,0.25);
  margin-bottom: 6px;
}
.stat img {
  width: 28px;
  height: 28px;
  image-rendering: pixelated;
}
  .center {
    background: #111;
    border: 2px solid #f33;
    border-radius: 12px;
    min-height: 0; /* allow children to shrink for scrolling */
    height: 100%;
    display: flex;
    flex-direction: column;
    max-width: none; /* fill available width to avoid narrow center */
    margin: 0;
    width: 100%;
    box-sizing: border-box;
    overflow: hidden; /* inner grid scrolls */
  }
  .toolbar { display:flex; gap:8px; align-items:center; padding:8px; border-bottom:2px solid #f33; flex-wrap:wrap; }
  input[type='search'], select, button { background:#1b1216; color:#f33; border:1px solid #f33; border-radius:8px; padding:6px 10px; }
  .grid {
    flex: 1 1 auto;
    min-height: 0; /* required for child scroll in flex */
    overflow: auto; /* make the compendium the scrollable area */
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 10px;
    padding: 14px;
    justify-items: stretch;
    align-content: start;
    width: 100%;
    box-sizing: border-box;
  }

  /* Advanced Compendium Styles */
  .view-mode {
    padding: 6px 12px;
    background: transparent;
    border: none;
    border-radius: 18px;
    color: #aaa;
    cursor: pointer;
    font-size: 13px;
    transition: all 0.2s ease;
  }
  .view-mode.active {
    background: #3498db;
    color: white;
  }

  .tier-btn {
    padding: 4px 12px;
    background: transparent;
    border: none;
    border-radius: 14px;
    color: #aaa;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s ease;
  }
  .tier-btn.active {
    background: linear-gradient(135deg, #f39c12, #e67e22);
    color: white;
  }

  .needs-review-toggle {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 6px 10px;
    background: rgba(255, 193, 7, 0.1);
    border: 1px solid rgba(255, 193, 7, 0.3);
    border-radius: 16px;
    color: #ffc107;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s ease;
  }
  .needs-review-toggle:hover {
    background: rgba(255, 193, 7, 0.2);
  }
  .review-count {
    background: #ffc107;
    color: #000;
    border-radius: 10px;
    padding: 2px 6px;
    font-weight: bold;
    min-width: 16px;
    text-align: center;
  }

  .quick-action-btn {
    padding: 6px 12px;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 16px;
    color: #fff;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s ease;
  }
  .quick-action-btn:hover {
    background: rgba(255,255,255,0.2);
  }
  .primary-action-btn {
    padding: 8px 16px;
    background: #0f3;
    border: 1px solid #0f3;
    border-radius: 16px;
    color: #000;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
  }

  .search-chips {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
  }
  .search-chip {
    background: rgba(52, 152, 219, 0.2);
    border: 1px solid rgba(52, 152, 219, 0.4);
    border-radius: 12px;
    padding: 2px 8px;
    color: #3498db;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  .search-chip .remove {
    margin-left: 4px;
    font-weight: bold;
  }

  .filter-sidebar {
    scrollbar-width: thin;
    scrollbar-color: rgba(255,255,255,0.3) transparent;
  }
  .filter-sidebar::-webkit-scrollbar {
    width: 6px;
  }
  .filter-sidebar::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,0.3);
    border-radius: 3px;
  }

  .filter-group {
    margin-bottom: 20px;
    padding: 0 16px;
  }
  .filter-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  .filter-header h4 {
    margin: 0;
    color: #fff;
    font-size: 13px;
    font-weight: bold;
  }
  .filter-clear {
    background: none;
    border: none;
    color: #e74c3c;
    cursor: pointer;
    font-size: 11px;
    padding: 2px 4px;
  }

  .filter-options label {
    display: block;
    padding: 4px 0;
    color: #ccc;
    font-size: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .filter-options input[type="checkbox"] {
    margin: 0;
    accent-color: #3498db;
  }
  .filter-count {
    color: #666;
    font-size: 11px;
  }

  .tag-family {
    margin-bottom: 12px;
  }
  .tag-family-header {
    font-weight: bold;
    color: #3498db;
    font-size: 11px;
    margin-bottom: 4px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .stat-slider {
    margin-bottom: 12px;
  }
  .stat-slider label {
    display: block;
    color: #ccc;
    font-size: 12px;
    margin-bottom: 4px;
  }
  .stat-slider input[type="range"] {
    background: rgba(255,255,255,0.1);
    border: none;
    border-radius: 10px;
    height: 6px;
  }

  .item-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 16px;
  }

  .item-table {
    width: 100%;
    border-collapse: collapse;
    background: rgba(255,255,255,0.02);
    border-radius: 8px;
    overflow: hidden;
  }
  .item-table th {
    background: rgba(255,255,255,0.1);
    color: #fff;
    padding: 12px;
    text-align: left;
    font-weight: bold;
    cursor: pointer;
    position: relative;
  }
  .item-table th.sortable:hover {
    background: rgba(255,255,255,0.15);
  }
  .item-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    color: #ccc;
    font-size: 13px;
  }
  .item-table tbody tr:hover {
    background: rgba(255,255,255,0.05);
  }

  .compare-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin-top: 20px;
  }

  .modal-close {
    position: absolute;
    top: 16px;
    right: 20px;
    background: none;
    border: none;
    font-size: 24px;
    color: #fff;
    cursor: pointer;
    z-index: 1;
  }

  .qa-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    border-bottom: 1px solid rgba(255,255,255,0.1);
  }
  .qa-header h3 {
    margin: 0;
    color: #fff;
    font-size: 16px;
  }
  .qa-content {
    padding: 20px;
  }

  /* Mini card styling for filled slots and weapon */
  .miniCard {
    display:flex; align-items:center; gap:8px;
    border:2px solid #f33; border-radius:12px; padding:6px 8px;
    background:#111; color:#fff; box-shadow: 0 2px 8px rgba(255,51,51,0.15);
  }
  .miniCard img { width:28px; height:28px; image-rendering:pixelated; }
  .slot.filled { border-style:solid; }
  .slot.filled .miniCard .name { font-size:12px; color:#faa; }

  .card {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    border: 2px solid #f33;
    border-radius: 16px;
    padding: 14px;
    background: #111;
    color: #fff;
    font-size: 12px;
    max-width: 420px;
    width: 100%;
    box-sizing: border-box;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(255, 51, 51, 0.2);
  }

  .card:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(255, 51, 51, 0.3);
    border-color: #f55;
    background: #1a1a1a;
  }

  .card[data-cat="Jewelry"] { border-color: #ffd166; box-shadow: 0 4px 12px rgba(255, 209, 102, 0.2); }
  .card[data-cat="Jewelry"]:hover { border-color: #ffe0a3; box-shadow: 0 6px 16px rgba(255, 209, 102, 0.3); }

  .card[data-cat="Tome"] { border-color: #73d2de; box-shadow: 0 4px 12px rgba(115, 210, 222, 0.2); }
  .card[data-cat="Tome"]:hover { border-color: #a1e3eb; box-shadow: 0 6px 16px rgba(115, 210, 222, 0.3); }

  .card[data-cat="Food"] { border-color: #95d5b2; box-shadow: 0 4px 12px rgba(149, 213, 178, 0.2); }
  .card[data-cat="Food"]:hover { border-color: #b7e4cc; box-shadow: 0 6px 16px rgba(149, 213, 178, 0.3); }
  .card[data-cat="Jewelry"]{ border-color:#ffd166; }
  .card[data-cat="Tome"]{ border-color:#73d2de; }
  .card[data-cat="Food"]{ border-color:#95d5b2; }
  /* Keyboard focus ring for cards */
  .card:focus-visible { outline: 2px solid #f55; outline-offset: 2px; }
  /* Clamp effect text to two lines inside cards */
  .card .effect {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  /* Optional: visible focus ring on slots for future keyboard nav */
  .slot:focus-visible { outline: 2px solid #f55; outline-offset: 3px; }
  /* Selected slot highlight */
.slot.active { box-shadow: 0 0 0 3px #f55 inset; background:#120; }
  /* Card quick actions (Add P / Add O) - REMOVED */
  .card__actions { display:none !important; }
  .card__btn { display:none !important; }
  .selIndicator { font-size: 12px; color:#faa; margin:4px 2px; }
.card .iconWrap { position:relative; }
.card .iconWrap img { width:48px; height:48px; image-rendering:pixelated; }
.card .badge { position:absolute; top:-6px; right:-6px; background:#210; border:1px solid #f33; border-radius:6px; padding:2px 4px; font-size:12px; }
.card .nameUnder { text-align:center; font-size:12px; }

/* Set bonus chips */
.setsBox { display:flex; flex-wrap:wrap; gap:6px; padding-top:8px; border-top:2px solid #f33; margin-top:8px; }
.setChip { display:inline-flex; align-items:center; gap:6px; background:#210; border:1px solid #f33; border-radius:12px; padding:4px 8px; font-size:12px; color:#faa; }
.setChip .name { font-weight:700; color:#fff; }
.setChip img { width:18px; height:18px; image-rendering:pixelated; }

/* Floating simulation panel styling */
/* Simulation panel now in center column, below compendium */
#simPanel {
  width:480px;
  margin:24px auto 0 auto;
  background:#000;
  border:2px solid #f33;
  border-radius:16px;
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:12px;
  z-index:10;
  position:static;
}
#simControls { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
#simLog {
  flex:1;
  min-height:180px;
  max-height:320px;
  overflow:auto;
  background:#111;
  border:2px solid #f33;
  border-radius:12px;
  padding:14px;
  font-size:16px;
  font-family:monospace;
  color:#f66;
  white-space:pre-wrap;
}
.meta .name { font-weight:700; }
.meta .slug { font-size:12px; color:#f66; }
.meta .effect { font-size:12px; margin-top:6px; color:#faa; }
.meta .stats { display:flex; gap:6px; flex-wrap:wrap; margin-top:8px; }
.pill {
  display: flex;
  align-items: center;
  gap: 8px;
  background: #2f5d1a;
  border: 2px solid #95d5b2;
  border-radius: 999px;
  padding: 8px 18px;
  font-size: 18px;
  color: #fff;
  font-weight: bold;
  box-shadow: 0 2px 8px rgba(149,213,178,0.25);
}
.pill img {
  width: 22px;
  height: 22px;
  image-rendering: pixelated;
}
.drag-over { outline:2px dashed #f33; }

#detailModal { position:fixed; inset:0; background:rgba(0,0,0,0.8); display:none; align-items:center; justify-content:center; z-index:1000; }
#detailBox { background:#111; border:2px solid #f33; border-radius:12px; padding:16px; color:#f66; max-width:400px; }
#detailBox h2 { margin-top:0; }
#detailClose { background:#333; color:#f33; border:1px solid #f33; border-radius:6px; padding:2px 6px; float:right; cursor:pointer; }
#detailStats { display:flex; gap:6px; flex-wrap:wrap; margin-top:8px; }

/* Battle Analysis System Styles */
.outcome-kpis .kpi-item {
  text-align: center;
  min-width: 80px;
}

.outcome-kpis .kpi-label {
  font-size: 11px;
  color: #aaa;
  text-transform: uppercase;
  font-weight: 500;
  margin-bottom: 2px;
}

.outcome-kpis .kpi-value {
  font-size: 16px;
  font-weight: bold;
  color: #fff;
}

.analysis-panel {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  margin-bottom: 16px;
  overflow: hidden;
}

.analysis-panel-header {
  background: rgba(255, 255, 255, 0.05);
  padding: 12px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  cursor: pointer;
}

.analysis-panel-header h3 {
  margin: 0;
  font-size: 16px;
  color: #fff;
  font-weight: 600;
}

.analysis-toggle {
  background: none;
  border: none;
  color: #aaa;
  font-size: 18px;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.analysis-toggle:hover {
  color: #fff;
}

.analysis-panel-content {
  padding: 16px;
  color: #ccc;
}

.analysis-panel.collapsed .analysis-panel-content {
  display: none;
}

.analysis-panel.collapsed .analysis-toggle {
  transform: rotate(90deg);
}

/* Damage Sources */
.damage-chart {
  margin-bottom: 12px;
}

.damage-bar {
  display: flex;
  align-items: center;
  margin-bottom: 6px;
  font-size: 12px;
}

.damage-bar-fill {
  height: 20px;
  background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
  margin-right: 8px;
  border-radius: 2px;
}

.damage-source-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 8px;
  background: rgba(255, 255, 255, 0.02);
  margin-bottom: 4px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}

.damage-source-item:hover {
  background: rgba(255, 255, 255, 0.05);
}

.damage-source-name {
  color: #fff;
  font-weight: 500;
}

.damage-source-value {
  color: #ff6b6b;
  font-weight: bold;
}

.damage-source-percent {
  color: #aaa;
  font-size: 11px;
  margin-left: 4px;
}

/* Status Impact */
.status-impact-item {
  margin-bottom: 12px;
  padding: 8px;
  background: rgba(255, 255, 255, 0.02);
  border-radius: 4px;
}

.status-impact-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
}

.status-impact-name {
  font-weight: 500;
  color: #fff;
}

.status-impact-total {
  color: #4a9eff;
  font-weight: bold;
}

.status-impact-details {
  font-size: 11px;
  color: #aaa;
  line-height: 1.4;
}

/* Trigger Heatmap */
.heatmap-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 11px;
}

.heatmap-table th,
.heatmap-table td {
  border: 1px solid rgba(255, 255, 255, 0.1);
  padding: 6px 4px;
  text-align: center;
}

.heatmap-table th {
  background: rgba(255, 255, 255, 0.05);
  color: #fff;
  font-weight: 500;
}

.heatmap-cell {
  background: rgba(74, 158, 255, 0.1);
  color: #4a9eff;
  cursor: pointer;
  transition: background 0.2s;
}

.heatmap-cell:hover {
  background: rgba(74, 158, 255, 0.2);
}

.heatmap-cell.dead {
  background: rgba(255, 107, 107, 0.1);
  color: #666;
}

/* Synergy Tags */
.synergy-callout {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  background: rgba(156, 136, 255, 0.1);
  border: 1px solid rgba(156, 136, 255, 0.3);
  border-radius: 6px;
  margin-bottom: 8px;
  font-size: 12px;
}

.synergy-callout-icon {
  font-size: 16px;
}

.synergy-callout-text {
  flex: 1;
  color: #9c88ff;
}

.anti-synergy-warning {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  background: rgba(255, 107, 107, 0.1);
  border: 1px solid rgba(255, 107, 107, 0.3);
  border-radius: 6px;
  margin-bottom: 8px;
  font-size: 12px;
}

.anti-synergy-warning-icon {
  font-size: 16px;
  color: #ff6b6b;
}

.anti-synergy-warning-text {
  flex: 1;
  color: #ff6b6b;
}

/* Recommendations */
.recommendation-item {
  padding: 12px;
  background: rgba(38, 222, 129, 0.1);
  border: 1px solid rgba(38, 222, 129, 0.3);
  border-radius: 6px;
  margin-bottom: 8px;
}

.recommendation-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
}

.recommendation-title {
  color: #26de81;
  font-weight: 500;
  font-size: 13px;
}

.recommendation-gain {
  color: #26de81;
  font-size: 11px;
  font-weight: bold;
}

.recommendation-description {
  color: #ccc;
  font-size: 12px;
  line-height: 1.4;
}

/* Why Inspector */
.why-inspector.open {
  right: 0;
}

.why-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  background: rgba(255, 255, 255, 0.05);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.why-header h3 {
  margin: 0;
  color: #fff;
  font-size: 16px;
}

#closeWhyInspector {
  background: none;
  border: none;
  color: #aaa;
  font-size: 20px;
  cursor: pointer;
  padding: 0;
  width: 24px;
  height: 24px;
}

#closeWhyInspector:hover {
  color: #fff;
}

.why-content {
  padding: 16px;
}

.causal-step {
  margin-bottom: 12px;
  padding: 8px;
  background: rgba(255, 255, 255, 0.02);
  border-radius: 4px;
  border-left: 3px solid #4a9eff;
}

.causal-step-header {
  font-weight: 500;
  color: #4a9eff;
  font-size: 12px;
  margin-bottom: 4px;
}

.causal-step-details {
  color: #ccc;
  font-size: 11px;
  line-height: 1.4;
}

/* Sparklines */
.sparkline {
  display: inline-block;
  width: 40px;
  height: 16px;
  margin-left: 6px;
  vertical-align: middle;
}

.sparkline-bar {
  display: inline-block;
  width: 2px;
  background: #4a9eff;
  margin-right: 1px;
  border-radius: 1px;
}

.emptySlot {
  color: #666;
  font-style: italic;
  text-align: center;
  padding: 20px;
}

/* Simulation enhancements */

@keyframes battle-glow {
  0%, 100% { box-shadow: 0 0 40px rgba(0,255,51,0.2); }
  50% { box-shadow: 0 0 60px rgba(0,255,51,0.4); }
}

.battle-button {
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.battle-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0,255,51,0.4);
}

.battle-button:active {
  transform: translateY(0);
}

.battle-log-line {
  border-left: 3px solid transparent;
  padding-left: 8px;
  margin: 4px 0;
  transition: all 0.2s ease;
  line-height: 1.8;
}

.battle-log-line.player {
  border-left-color: #0f3;
}

.battle-log-line.opponent {
  border-left-color: #f33;
}

.battle-log-line.system {
  border-left-color: #fa0;
}

.battle-log-line:hover {
  background: rgba(0,255,51,0.1);
  border-radius: 4px;
}

/* Enhanced player name styling */
.player-name {
  font-weight: bold;
  font-size: 18px;
  text-shadow: 0 0 8px currentColor;
  padding: 2px 0;
}

.player-name.player-1 {
  color: #00ff88 !important;
  text-shadow: 0 0 8px #00ff88;
}

.player-name.player-2 {
  color: #ff4466 !important;
  text-shadow: 0 0 8px #ff4466;
}

/* Section dividers */
.battle-divider {
  margin: 12px 0;
  padding: 8px 0;
  border-top: 2px solid rgba(255,255,255,0.2);
  border-bottom: 1px solid rgba(255,255,255,0.1);
  text-align: center;
  color: #888;
  font-style: italic;
  font-size: 14px;
}

.battle-divider.major {
  border-top: 3px solid #0f3;
  color: #0f3;
  font-weight: bold;
  font-size: 16px;
  margin: 16px 0;
}

.sim-preview-item {
  display: inline-block;
  width: 24px;
  height: 24px;
  border: 1px solid #333;
  border-radius: 4px;
  margin: 2px;
  background: #111;
  image-rendering: pixelated;
}

.result-victory {
  color: #0f3;
  text-shadow: 0 0 10px rgba(0,255,51,0.5);
  font-weight: 900;
}

.result-defeat {
  color: #f33;
  text-shadow: 0 0 10px rgba(255,51,51,0.5);
  font-weight: 900;
}

/* Battle Replay System Styles */
.replay-btn {
  transition: all 0.2s ease;
  font-size: 14px;
  min-width: 40px;
}

.replay-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 2px 8px rgba(0,255,51,0.3);
}

.replay-btn:active {
  transform: scale(0.95);
}

.replay-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

/* Three-Pane Layout Specific Styles */
.fighter-card {
  transition: all 0.3s ease;
}

.fighter-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,255,51,0.2);
}

.fighter-card.opponent-card:hover {
  box-shadow: 0 4px 12px rgba(255,51,51,0.2);
}

.stat-chip {
  transition: all 0.2s ease;
}

.stat-chip:hover {
  transform: scale(1.05);
}

.status-chip {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  background: rgba(255,255,255,0.1);
  border: 1px solid #666;
  border-radius: 12px;
  padding: 2px 6px;
  font-size: 10px;
  color: #ccc;
  transition: all 0.2s ease;
}

.status-chip:hover {
  background: rgba(255,255,255,0.2);
  transform: scale(1.1);
}

.status-chip.poison { border-color: #8a2be2; color: #8a2be2; }
.status-chip.thorns { border-color: #8b4513; color: #8b4513; }
.status-chip.regen { border-color: #32cd32; color: #32cd32; }
.status-chip.stun { border-color: #ffd700; color: #ffd700; }
.status-chip.acid { border-color: #adff2f; color: #adff2f; }
.status-chip.freeze { border-color: #87ceeb; color: #87ceeb; }
.status-chip.riptide { border-color: #4169e1; color: #4169e1; }
.status-chip.purity { border-color: #f0f8ff; color: #f0f8ff; }

/* Enhanced status chip micro-patterns */
.status-chip-icon {
  font-size: 10px;
}

.status-chip-value {
  font-weight: bold;
  color: inherit;
}

.status-chip-trend {
  font-size: 8px;
  opacity: 0.8;
  margin-left: 2px;
}

.status-chip-trend.positive { color: #0f3; }
.status-chip-trend.negative { color: #f33; }

/* Enhanced phase headers */
.log-phase-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: linear-gradient(135deg, #2a3441 0%, #1e2832 100%);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  cursor: pointer;
  font-weight: 600;
}

.phase-title {
  font-size: 13px;
  color: #fff;
}

.phase-meta {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 11px;
  color: #aaa;
}

.trigger-count {
  background: rgba(255, 255, 255, 0.1);
  padding: 1px 6px;
  border-radius: 8px;
  font-weight: 500;
}

/* Effect rows with enhanced styling */
.effect-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  font-size: 12px;
}

.effect-source {
  color: #4a9eff;
  font-weight: 500;
  min-width: 80px;
}

.effect-arrow {
  color: #666;
  font-weight: normal;
}

.effect-target {
  color: #ff6b6b;
  font-weight: 500;
}

.effect-description {
  color: #ccc;
  flex: 1;
}

/* Synergy tags */
.synergy-tag {
  display: inline-block;
  background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
  color: white;
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 600;
  margin: 1px 2px;
  box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.synergy-tag.symphony { 
  background: linear-gradient(135deg, #9c88ff 0%, #7c4dff 100%);
}

.synergy-tag.bomb { 
  background: linear-gradient(135deg, #ff9500 0%, #ff6b35 100%);
}

.synergy-tag.fruit { 
  background: linear-gradient(135deg, #26de81 0%, #20bf6b 100%);
}

/* Summary strip */
.summary-strip {
  display: flex;
  gap: 12px;
  padding: 8px 12px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  font-size: 11px;
  font-weight: 500;
  margin: 4px 0;
}

.summary-stat {
  display: flex;
  align-items: center;
  gap: 4px;
  color: #ccc;
}

.summary-stat-value {
  color: #fff;
  font-weight: bold;
}

.summary-stat.damage .summary-stat-value { color: #ff6b6b; }
.summary-stat.healing .summary-stat-value { color: #26de81; }
.summary-stat.strikes .summary-stat-value { color: #4a9eff; }
.summary-stat.cooldown .summary-stat-value { color: #ffa726; }

.delta-indicator {
  font-size: 10px;
  font-weight: 700;
  margin-left: 4px;
  animation: deltaFlash 0.6s ease-in-out;
}

.delta-indicator.positive { color: #0f3; }
.delta-indicator.negative { color: #f33; }

@keyframes deltaFlash {
  0% { opacity: 0; transform: scale(1.5); }
  50% { opacity: 1; transform: scale(1.2); }
  100% { opacity: 1; transform: scale(1); }
}

/* Loadout tray styles */
.loadout-item {
  display: flex;
  align-items: center;
  gap: 8px;
  background: rgba(255,255,255,0.05);
  border: 1px solid #333;
  border-radius: 6px;
  padding: 6px 8px;
  font-size: 11px;
  transition: all 0.2s ease;
}

.loadout-item:hover {
  background: rgba(255,255,255,0.1);
  border-color: #666;
}

.loadout-item img {
  width: 20px;
  height: 20px;
  image-rendering: pixelated;
}

.loadout-item.weapon {
  border-color: #ff9900;
  color: #ff9900;
}

.loadout-item.tier-gold {
  box-shadow: 0 0 4px rgba(255,215,0,0.3);
}

.loadout-item.tier-diamond {
  box-shadow: 0 0 4px rgba(185,242,255,0.3);
}

/* Phase-based log styling */
.log-phase-card {
  margin: 12px 0;
  background: rgba(255,255,255,0.02);
  border: 1px solid #333;
  border-radius: 8px;
  overflow: hidden;
  transition: all 0.2s ease;
}

.log-phase-card.expanded {
  border-color: #666;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.log-phase-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  background: rgba(255,255,255,0.05);
  cursor: pointer;
  transition: all 0.2s ease;
}

.log-phase-header:hover {
  background: rgba(255,255,255,0.08);
}

.log-phase-header.battle-start { border-left: 4px solid #0f3; }
.log-phase-header.turn-start { border-left: 4px solid #fa0; }
.log-phase-header.strike { border-left: 4px solid #f33; }
.log-phase-header.wounded { border-left: 4px solid #f0a; }
.log-phase-header.exposed { border-left: 4px solid #af5; }
.log-phase-header.countdown { border-left: 4px solid #5af; }

.log-phase-summary {
  font-size: 11px;
  color: #888;
  font-style: italic;
}

.log-phase-content {
  padding: 12px;
  border-top: 1px solid #333;
  display: none;
  font-size: 12px;
  line-height: 1.5;
}

.log-phase-content.expanded {
  display: block;
  animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
  from { opacity: 0; transform: translateY(-8px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Enhanced battle log with replay features */
.battle-log-line {
  border-left: 3px solid transparent;
  padding-left: 8px;
  margin: 4px 0;
  transition: all 0.2s ease;
  line-height: 1.8;
  cursor: pointer;
  position: relative;
}

.battle-log-line.active {
  background: rgba(0,255,51,0.15);
  border-radius: 4px;
  border-left-color: #0f3;
  box-shadow: 0 0 15px rgba(0,255,51,0.2);
  transform: translateX(4px);
}

.battle-log-line.current-turn {
  background: rgba(255,215,0,0.1);
  border-left-color: #ffd700;
  animation: pulse-gold 2s ease-in-out infinite;
}

@keyframes pulse-gold {
  0%, 100% { box-shadow: 0 0 5px rgba(255,215,0,0.3); }
  50% { box-shadow: 0 0 20px rgba(255,215,0,0.6); }
}

.battle-log-line .log-icon {
  width: 16px;
  height: 16px;
  margin-right: 6px;
  vertical-align: middle;
  image-rendering: pixelated;
  opacity: 0.9;
}

.battle-log-line .turn-marker {
  position: absolute;
  left: -20px;
  top: 50%;
  transform: translateY(-50%);
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: #0a5;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.battle-log-line.active .turn-marker {
  opacity: 1;
}

/* HP tracking in log lines */
.hp-tracker {
  font-size: 12px;
  color: #888;
  margin-left: 8px;
  font-weight: normal;
}

.hp-tracker.player {
  color: #0a8;
}

.hp-tracker.opponent {
  color: #a55;
}

.result-draw {
  color: #fa0;
  text-shadow: 0 0 10px rgba(255,170,0,0.5);
  font-weight: 900;
}
</style>
</head>
<body>
<header><h1>He Is Coming √¢‚Ç¨‚Äù Loadout Builder (v5)</h1></header>
<div class="frame">
  <!-- LEFT / PLAYER -->
  <section class="panel" id="panelP">
    <div class="title">Oils</div>
    <div class="oils" id="oilsP">
      <div class="oil" data-kind="attack"><img src="assets/attack.png"><span>Attack Oil</span></div>
      <div class="oil" data-kind="armor"><img src="assets/armor.png"><span>Armor Oil</span></div>
      <div class="oil" data-kind="speed"><img src="assets/speed.png"><span>Speed Oil</span></div>
    </div>
    <div class="weapon-slot" id="weaponP">Drop a Weapon</div>
    <div class="edge-tile">
      <div class="edge-body">
        <img id="edgePIcon" src="assets/placeholder.png" alt="">
        <select id="edgeP"><option value="">√¢‚Ç¨‚Äù Select Edge √¢‚Ç¨‚Äù</option></select>
      </div>
      <div id="edgePEffect" class="meta effect"></div>
    </div>
    <div class="selIndicator" id="selPI">Selected: None</div>
    <div class="grid12" id="gridP"></div>
    <div class="stats">
      <div class="stat"><img src="assets/health.png" alt="health"><span id="pH">10</span></div>
      <div class="stat"><img src="assets/attack.png" alt="atk"><span id="pA">0</span></div>
      <div class="stat"><img src="assets/armor.png" alt="arm"><span id="pR">0</span></div>
      <div class="stat"><img src="assets/speed.png" alt="spd"><span id="pS">0</span></div>
    </div>
    <div class="setsBox" id="setsP"></div>
  </section>

  <!-- CENTER COLUMN -->
  <div style="grid-column: 2; display: flex; flex-direction: column; height: 100%; min-height:0;">
    <div class="tabs" style="display:flex; gap:2px; margin-bottom:8px;">
      <button id="tabCompendium" class="tabBtn" style="background:#111;color:#f33;border:2px solid #f33;border-radius:8px 8px 0 0;padding:8px 24px;cursor:pointer;font-size:16px;">Compendium</button>
      <button id="tabAnalysis" class="tabBtn" style="background:#111;color:#fa0;border:2px solid #fa0;border-radius:8px 8px 0 0;padding:8px 24px;cursor:pointer;font-size:16px;">Analysis</button>
      <button id="tabSimulation" class="tabBtn" style="background:#111;color:#0f3;border:2px solid #0f3;border-radius:8px 8px 0 0;padding:8px 24px;cursor:pointer;font-size:16px;">Simulation</button>
    </div>
    <section class="center" id="compendiumTab" style="flex:1; display:flex; flex-direction:column; min-height:0;">
      
      <!-- Advanced Search & Control Bar -->
      <div class="compendium-header" style="
        background: linear-gradient(135deg, #1a1f2e 0%, #16202d 100%); 
        padding: 16px; 
        border-bottom: 1px solid rgba(255,255,255,0.1);
        position: sticky;
        top: 0;
        z-index: 100;
      ">
        <!-- Primary Search Row -->
        <div class="search-row" style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
          <div class="search-box-container" style="flex: 1; position: relative; max-width: 400px;">
            <input id="globalSearch" type="search" placeholder="Search items, effects, tags..." style="
              width: 100%; 
              padding: 8px 12px 8px 36px; 
              border: 2px solid rgba(255,255,255,0.2); 
              border-radius: 20px; 
              background: rgba(0,0,0,0.3); 
              color: #fff; 
              font-size: 14px;
            ">
            <div class="search-icon" style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #aaa;">üîç</div>
            <div id="searchChips" class="search-chips" style="margin-top: 6px; display: flex; flex-wrap: wrap; gap: 4px;"></div>
          </div>
          
          <div class="view-switches" style="display: flex; align-items: center; gap: 8px;">
            <div class="view-mode-group" style="background: rgba(0,0,0,0.3); border-radius: 20px; padding: 2px; display: flex;">
              <button id="viewCards" class="view-mode active" data-mode="cards">Cards</button>
              <button id="viewTable" class="view-mode" data-mode="table">Table</button>
              <button id="viewCompare" class="view-mode" data-mode="compare">Compare</button>
            </div>
            
            <div class="tier-switcher" style="background: rgba(0,0,0,0.3); border-radius: 16px; padding: 2px; display: flex;">
              <button id="tierBase" class="tier-btn active" data-tier="base">Base</button>
              <button id="tierGold" class="tier-btn" data-tier="gold">Gold</button>
              <button id="tierDiamond" class="tier-btn" data-tier="diamond">Diamond</button>
            </div>
            
            <button id="needsReviewToggle" class="needs-review-toggle" title="Show only items needing review">
              <span class="review-icon">‚ö†</span>
              <span class="review-count" id="reviewCount">0</span>
            </button>
          </div>
        </div>
        
        <!-- Results Info & Quick Actions -->
        <div class="results-row" style="display: flex; align-items: center; justify-content: space-between;">
          <div class="results-info" style="color: #aaa; font-size: 13px;">
            <span id="resultCount">0 items</span>
            <span id="filterSummary"></span>
          </div>
          
          <div class="quick-actions" style="display: flex; gap: 8px;">
            <button id="randBuildBtn" class="quick-action-btn" title="Fill your slots with random items">
              üé≤ Random Build
            </button>
            <button id="randEnemyBtn" class="quick-action-btn" title="Randomize opponent loadout">
              üé≤ Random Enemy
            </button>
            <button id="exportVisible" class="quick-action-btn" title="Export filtered results to JSON">
              üìã Export
            </button>
            <button id="showSimBtn" class="primary-action-btn">Show Simulation</button>
          </div>
        </div>
      </div>
      
      <!-- Main Content Area -->
      <div class="compendium-main" style="flex: 1; display: flex; min-height: 0;">
        
        <!-- Left Sidebar - Faceted Filters -->
        <div id="filterSidebar" class="filter-sidebar" style="
          width: 280px; 
          background: rgba(255,255,255,0.02); 
          border-right: 1px solid rgba(255,255,255,0.1);
          overflow-y: auto;
          padding: 16px 0;
        ">
          
          <!-- Bucket Filter -->
          <div class="filter-group">
            <div class="filter-header">
              <h4>Type</h4>
              <button class="filter-clear" data-filter="bucket">Clear</button>
            </div>
            <div class="filter-options" id="bucketFilters">
              <label><input type="checkbox" value="items"> <span class="filter-count">(0)</span> Items</label>
              <label><input type="checkbox" value="weapons"> <span class="filter-count">(0)</span> Weapons</label>
              <label><input type="checkbox" value="sets"> <span class="filter-count">(0)</span> Sets</label>
              <label><input type="checkbox" value="upgrades"> <span class="filter-count">(0)</span> Upgrades</label>
            </div>
          </div>
          
          <!-- Tag Families Filter -->
          <div class="filter-group">
            <div class="filter-header">
              <h4>Tags</h4>
              <button class="filter-clear" data-filter="tags">Clear</button>
            </div>
            <div class="filter-options" id="tagFilters">
              <div class="tag-family">
                <div class="tag-family-header">Combat</div>
                <label><input type="checkbox" value="Tome"> <span class="filter-count">(0)</span> Tome</label>
                <label><input type="checkbox" value="Bomb"> <span class="filter-count">(0)</span> Bomb</label>
                <label><input type="checkbox" value="Symphony"> <span class="filter-count">(0)</span> Symphony</label>
              </div>
              <div class="tag-family">
                <div class="tag-family-header">Materials</div>
                <label><input type="checkbox" value="Stone"> <span class="filter-count">(0)</span> Stone</label>
                <label><input type="checkbox" value="Wood"> <span class="filter-count">(0)</span> Wood</label>
                <label><input type="checkbox" value="Water"> <span class="filter-count">(0)</span> Water</label>
              </div>
              <div class="tag-family">
                <div class="tag-family-header">Status Effects</div>
                <label><input type="checkbox" value="Poison"> <span class="filter-count">(0)</span> Poison</label>
                <label><input type="checkbox" value="Freeze"> <span class="filter-count">(0)</span> Freeze</label>
                <label><input type="checkbox" value="Acid"> <span class="filter-count">(0)</span> Acid</label>
                <label><input type="checkbox" value="Riptide"> <span class="filter-count">(0)</span> Riptide</label>
              </div>
              <div class="tag-family">
                <div class="tag-family-header">Other</div>
                <label><input type="checkbox" value="Food"> <span class="filter-count">(0)</span> Food</label>
                <label><input type="checkbox" value="Jewelry"> <span class="filter-count">(0)</span> Jewelry</label>
                <label><input type="checkbox" value="Rose"> <span class="filter-count">(0)</span> Rose</label>
              </div>
            </div>
          </div>
          
          <!-- Trigger Filter -->
          <div class="filter-group">
            <div class="filter-header">
              <h4>Triggers</h4>
              <button class="filter-clear" data-filter="triggers">Clear</button>
            </div>
            <div class="filter-options" id="triggerFilters">
              <label><input type="checkbox" value="battleStart"> <span class="filter-count">(0)</span> Battle Start</label>
              <label><input type="checkbox" value="turnStart"> <span class="filter-count">(0)</span> Turn Start</label>
              <label><input type="checkbox" value="onHit"> <span class="filter-count">(0)</span> On Hit</label>
              <label><input type="checkbox" value="onWounded"> <span class="filter-count">(0)</span> On Wounded</label>
              <label><input type="checkbox" value="onExposed"> <span class="filter-count">(0)</span> On Exposed</label>
              <label><input type="checkbox" value="countdown"> <span class="filter-count">(0)</span> Countdown</label>
              <label><input type="checkbox" value="passive"> <span class="filter-count">(0)</span> Passive</label>
            </div>
          </div>
          
          <!-- Stat Ranges -->
          <div class="filter-group">
            <div class="filter-header">
              <h4>Stats</h4>
              <button class="filter-clear" data-filter="stats">Clear</button>
            </div>
            <div class="stat-sliders">
              <div class="stat-slider">
                <label>Attack: <span id="attackValue">Any</span></label>
                <input type="range" id="attackSlider" min="0" max="10" value="0" style="width: 100%;">
              </div>
              <div class="stat-slider">
                <label>Armor: <span id="armorValue">Any</span></label>
                <input type="range" id="armorSlider" min="0" max="10" value="0" style="width: 100%;">
              </div>
              <div class="stat-slider">
                <label>Health: <span id="healthValue">Any</span></label>
                <input type="range" id="healthSlider" min="0" max="20" value="0" style="width: 100%;">
              </div>
              <div class="stat-slider">
                <label>Speed: <span id="speedValue">Any</span></label>
                <input type="range" id="speedSlider" min="0" max="10" value="0" style="width: 100%;">
              </div>
            </div>
          </div>
          
          <!-- Advanced Filters -->
          <div class="filter-group">
            <div class="filter-header">
              <h4>Advanced</h4>
              <button class="filter-clear" data-filter="advanced">Clear</button>
            </div>
            <div class="filter-options">
              <label><input type="checkbox" id="hasTieredValues"> Has Tiered Values</label>
              <label><input type="checkbox" id="hasConditions"> Has Conditions</label>
              <label><input type="checkbox" id="firstTurnOnly"> First Turn Only</label>
            </div>
          </div>
          
        </div>
        
        <!-- Main Content Panel -->
        <div class="content-main" style="flex: 1; overflow: auto; position: relative;">
          
          <!-- Cards View -->
          <div id="cardsView" class="content-view active" style="padding: 16px;">
            <div id="itemGrid" class="item-grid"></div>
          </div>
          
          <!-- Table View -->
          <div id="tableView" class="content-view" style="display: none; padding: 16px;">
            <div class="table-container">
              <table id="itemTable" class="item-table">
                <thead>
                  <tr>
                    <th class="sortable" data-sort="name">Name</th>
                    <th class="sortable" data-sort="bucket">Type</th>
                    <th class="sortable" data-sort="tags">Tags</th>
                    <th>Triggers</th>
                    <th>Stats</th>
                    <th>Status Effects</th>
                    <th class="sortable" data-sort="tiered">Tiered</th>
                    <th>Issues</th>
                  </tr>
                </thead>
                <tbody id="tableBody"></tbody>
              </table>
            </div>
          </div>
          
          <!-- Compare View -->
          <div id="compareView" class="content-view" style="display: none; padding: 16px;">
            <div class="compare-header">
              <h3>Compare Items</h3>
              <div class="compare-instructions">Select 2-3 items from cards or table to compare side-by-side</div>
            </div>
            <div id="compareContainer" class="compare-container"></div>
          </div>
          
        </div>
        
      </div>
      
      <!-- Item Detail Modal -->
      <div id="itemDetailModal" class="item-detail-modal" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 1000;
        display: none;
        overflow-y: auto;
      ">
        <div class="modal-content" style="
          max-width: 900px;
          margin: 40px auto;
          background: #1a1f2e;
          border-radius: 12px;
          border: 1px solid rgba(255,255,255,0.2);
          position: relative;
        ">
          <button class="modal-close" id="closeItemDetail">√ó</button>
          <div id="itemDetailContent"></div>
        </div>
      </div>
      
      <!-- QA Panel (Drawer) -->
      <div id="qaPanel" class="qa-panel" style="
        position: fixed;
        top: 0;
        right: -400px;
        width: 400px;
        height: 100vh;
        background: #1a1f2e;
        border-left: 1px solid rgba(255,255,255,0.2);
        z-index: 1001;
        transition: right 0.3s ease;
        overflow-y: auto;
      ">
        <div class="qa-header">
          <h3>QA & Authoring Tools</h3>
          <button id="closeQAPanel">√ó</button>
        </div>
        <div class="qa-content">
          <div id="lintResults"></div>
          <div id="wikiDriftResults"></div>
          <div id="playgroundEditor"></div>
        </div>
      </div>
      
    </section>
    <section class="center" id="analysisTab" style="flex:1; display:none; flex-direction:column; min-height:0;">
      <!-- Battle Analysis Header -->
      <div class="analysis-header" style="background: linear-gradient(135deg, #1a1f2e 0%, #16202d 100%); padding: 16px; border-bottom: 1px solid rgba(255,255,255,0.1);">
        <h2 style="color: #fff; font-size: 24px; margin: 0; text-align: center;">Battle Analysis</h2>
        <p style="color: #aaa; font-size: 14px; margin: 8px 0 0 0; text-align: center;">Turn raw logs into insight: KPIs, breakdowns, and clear recommendations</p>
      </div>
      
      <!-- Outcome KPIs Sticky Strip -->
      <div id="outcomeKPIs" class="outcome-kpis" style="
        background: rgba(0,0,0,0.8); 
        padding: 12px 16px; 
        border-bottom: 1px solid rgba(255,255,255,0.1);
        display: flex;
        gap: 24px;
        flex-wrap: wrap;
        justify-content: center;
        position: sticky;
        top: 0;
        z-index: 10;
      ">
        <div class="kpi-item">
          <div class="kpi-label">TTK</div>
          <div class="kpi-value" id="kpiTTK">-</div>
        </div>
        <div class="kpi-item">
          <div class="kpi-label">Survived</div>
          <div class="kpi-value" id="kpiSurvived">-</div>
        </div>
        <div class="kpi-item">
          <div class="kpi-label">Damage Dealt</div>
          <div class="kpi-value" id="kpiDamageDealt">-</div>
        </div>
        <div class="kpi-item">
          <div class="kpi-label">Damage Taken</div>
          <div class="kpi-value" id="kpiDamageTaken">-</div>
        </div>
        <div class="kpi-item">
          <div class="kpi-label">Strike Uptime</div>
          <div class="kpi-value" id="kpiStrikeUptime">-</div>
        </div>
        <div class="kpi-item">
          <div class="kpi-label">Net Tempo</div>
          <div class="kpi-value" id="kpiNetTempo">-</div>
        </div>
      </div>
      
      <!-- Main Analysis Content -->
      <div class="analysis-content" style="
        flex: 1; 
        overflow: auto; 
        padding: 16px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        max-width: 1400px;
        margin: 0 auto;
        width: 100%;
      ">
        
        <!-- Left Column -->
        <div class="analysis-left">
          
          <!-- Damage Sources Panel -->
          <div class="analysis-panel" id="damageSources">
            <div class="analysis-panel-header">
              <h3>Damage Sources</h3>
              <button class="analysis-toggle">‚àí</button>
            </div>
            <div class="analysis-panel-content">
              <div class="damage-chart" id="damageChart"></div>
              <div class="damage-list" id="damageList"></div>
            </div>
          </div>
          
          <!-- Status Impact Panel -->
          <div class="analysis-panel" id="statusImpact">
            <div class="analysis-panel-header">
              <h3>Status Impact</h3>
              <button class="analysis-toggle">‚àí</button>
            </div>
            <div class="analysis-panel-content">
              <div id="statusBreakdown"></div>
            </div>
          </div>
          
          <!-- Armor Economy Panel -->
          <div class="analysis-panel" id="armorEconomy">
            <div class="analysis-panel-header">
              <h3>Armor Economy</h3>
              <button class="analysis-toggle">‚àí</button>
            </div>
            <div class="analysis-panel-content">
              <div id="armorFlow"></div>
            </div>
          </div>
          
        </div>
        
        <!-- Right Column -->
        <div class="analysis-right">
          
          <!-- Trigger Heatmap Panel -->
          <div class="analysis-panel" id="triggerHeatmap">
            <div class="analysis-panel-header">
              <h3>Trigger Heatmap</h3>
              <button class="analysis-toggle">‚àí</button>
            </div>
            <div class="analysis-panel-content">
              <div id="heatmapMatrix"></div>
            </div>
          </div>
          
          <!-- Synergy Detection Panel -->
          <div class="analysis-panel" id="synergyDetection">
            <div class="analysis-panel-header">
              <h3>Synergy Analysis</h3>
              <button class="analysis-toggle">‚àí</button>
            </div>
            <div class="analysis-panel-content">
              <div id="synergyCallouts"></div>
              <div id="antiSynergyWarnings"></div>
            </div>
          </div>
          
          <!-- Bottlenecks & Risks Panel -->
          <div class="analysis-panel" id="bottlenecks">
            <div class="analysis-panel-header">
              <h3>Bottlenecks & Risks</h3>
              <button class="analysis-toggle">‚àí</button>
            </div>
            <div class="analysis-panel-content">
              <div id="limitingFactors"></div>
              <div id="riskAlerts"></div>
            </div>
          </div>
          
          <!-- Recommendations Panel -->
          <div class="analysis-panel" id="recommendations">
            <div class="analysis-panel-header">
              <h3>Recommendations</h3>
              <button class="analysis-toggle">‚àí</button>
            </div>
            <div class="analysis-panel-content">
              <div id="recommendationList"></div>
            </div>
          </div>
          
        </div>
        
      </div>
      
      <!-- Why Inspector Side Panel -->
      <div id="whyInspector" class="why-inspector" style="
        position: fixed;
        top: 0;
        right: -400px;
        width: 400px;
        height: 100vh;
        background: #1a1f2e;
        border-left: 1px solid rgba(255,255,255,0.2);
        z-index: 1000;
        transition: right 0.3s ease;
        overflow-y: auto;
      ">
        <div class="why-header">
          <h3>Why Inspector</h3>
          <button id="closeWhyInspector">√ó</button>
        </div>
        <div class="why-content">
          <div id="causalChain"></div>
          <div id="neighbors"></div>
          <div id="firstTurnView"></div>
        </div>
      </div>
      
    </section>
    <section class="center" id="simulationTab" style="flex:1; display:none; flex-direction:column; min-height:0; background: #000;">
      <!-- Three-Pane Layout: Fighter Cards | Event Log | Loadout Tray -->
      <div class="sim-three-pane" style="display: grid; grid-template-columns: 320px 1fr 320px; gap: 12px; height: 100%; min-height: 0; padding: 12px;">
        
        <!-- LEFT PANE: Sticky Summary (Fighter Cards) -->
        <div class="fighter-summary-pane" style="display: flex; flex-direction: column; gap: 16px; background: #0a0a0a; border: 2px solid #333; border-radius: 12px; padding: 16px; overflow-y: auto; position: sticky; top: 0; height: fit-content; max-height: 100vh;">
          
          <!-- Pinned Key Numbers -->
          <div id="pinnedMetrics" style="background: rgba(0,50,20,0.8); border: 2px solid #0a5; border-radius: 8px; padding: 12px; margin-bottom: 8px;">
            <div style="color: #0a5; font-size: 12px; font-weight: 600; text-align: center; margin-bottom: 8px;">LIVE METRICS</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
              <div style="text-align: center;">
                <div style="color: #888;">Damage Dealt</div>
                <div id="totalDamageDealt" style="color: #f33; font-weight: 700;">0</div>
              </div>
              <div style="text-align: center;">
                <div style="color: #888;">Damage Taken</div>
                <div id="totalDamageTaken" style="color: #f33; font-weight: 700;">0</div>
              </div>
              <div style="text-align: center;">
                <div style="color: #888;">Strikes Queued</div>
                <div id="strikesQueued" style="color: #fa0; font-weight: 700;">0</div>
              </div>
              <div style="text-align: center;">
                <div style="color: #888;">Lethal ETA</div>
                <div id="lethalETA" style="color: #f0a; font-weight: 700;">‚àû</div>
              </div>
            </div>
          </div>

          <!-- Player Fighter Card -->
          <div class="fighter-card player-card" style="background: rgba(0,255,51,0.1); border: 2px solid #0f3; border-radius: 12px; padding: 14px;">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
              <h3 style="color: #0f3; margin: 0; font-size: 16px; text-shadow: 0 0 8px rgba(0,255,51,0.5);">PLAYER</h3>
              <div id="playerResult" style="font-size: 12px; font-weight: 600; display: none;"></div>
            </div>
            
            <!-- Core Stats -->
            <div class="core-stats" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px;">
              <div class="stat-chip" style="display: flex; align-items: center; gap: 6px; background: #1a1a1a; border: 1px solid #0f3; border-radius: 6px; padding: 6px 8px;">
                <img src="assets/health.png" style="width: 16px; height: 16px; image-rendering: pixelated;">
                <span style="color: #0f3; font-size: 14px; font-weight: 600;"><span id="playerHP">10</span>/<span id="playerMaxHP">10</span></span>
              </div>
              <div class="stat-chip" style="display: flex; align-items: center; gap: 6px; background: #1a1a1a; border: 1px solid #0f3; border-radius: 6px; padding: 6px 8px;">
                <img src="assets/armor.png" style="width: 16px; height: 16px; image-rendering: pixelated;">
                <span style="color: #0f3; font-size: 14px; font-weight: 600;" id="playerArmor">0</span>
              </div>
              <div class="stat-chip" style="display: flex; align-items: center; gap: 6px; background: #1a1a1a; border: 1px solid #0f3; border-radius: 6px; padding: 6px 8px;">
                <img src="assets/attack.png" style="width: 16px; height: 16px; image-rendering: pixelated;">
                <span style="color: #0f3; font-size: 14px; font-weight: 600;" id="playerAttack">0</span>
              </div>
              <div class="stat-chip" style="display: flex; align-items: center; gap: 6px; background: #1a1a1a; border: 1px solid #0f3; border-radius: 6px; padding: 6px 8px;">
                <img src="assets/speed.png" style="width: 16px; height: 16px; image-rendering: pixelated;">
                <span style="color: #0f3; font-size: 14px; font-weight: 600;" id="playerSpeed">0</span>
              </div>
            </div>

            <!-- Status Effects -->
            <div id="playerStatusEffects" class="status-effects" style="display: flex; flex-wrap: wrap; gap: 6px; min-height: 28px;">
              <div style="color: #666; font-size: 11px; font-style: italic;">No status effects</div>
            </div>
          </div>

          <!-- Opponent Fighter Card -->
          <div class="fighter-card opponent-card" style="background: rgba(255,51,51,0.1); border: 2px solid #f33; border-radius: 12px; padding: 14px;">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
              <h3 style="color: #f33; margin: 0; font-size: 16px; text-shadow: 0 0 8px rgba(255,51,51,0.5);">OPPONENT</h3>
              <div id="opponentResult" style="font-size: 12px; font-weight: 600; display: none;"></div>
            </div>
            
            <!-- Core Stats -->
            <div class="core-stats" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px;">
              <div class="stat-chip" style="display: flex; align-items: center; gap: 6px; background: #1a1a1a; border: 1px solid #f33; border-radius: 6px; padding: 6px 8px;">
                <img src="assets/health.png" style="width: 16px; height: 16px; image-rendering: pixelated;">
                <span style="color: #f33; font-size: 14px; font-weight: 600;"><span id="opponentHP">10</span>/<span id="opponentMaxHP">10</span></span>
              </div>
              <div class="stat-chip" style="display: flex; align-items: center; gap: 6px; background: #1a1a1a; border: 1px solid #f33; border-radius: 6px; padding: 6px 8px;">
                <img src="assets/armor.png" style="width: 16px; height: 16px; image-rendering: pixelated;">
                <span style="color: #f33; font-size: 14px; font-weight: 600;" id="opponentArmor">0</span>
              </div>
              <div class="stat-chip" style="display: flex; align-items: center; gap: 6px; background: #1a1a1a; border: 1px solid #f33; border-radius: 6px; padding: 6px 8px;">
                <img src="assets/attack.png" style="width: 16px; height: 16px; image-rendering: pixelated;">
                <span style="color: #f33; font-size: 14px; font-weight: 600;" id="opponentAttack">0</span>
              </div>
              <div class="stat-chip" style="display: flex; align-items: center; gap: 6px; background: #1a1a1a; border: 1px solid #f33; border-radius: 6px; padding: 6px 8px;">
                <img src="assets/speed.png" style="width: 16px; height: 16px; image-rendering: pixelated;">
                <span style="color: #f33; font-size: 14px; font-weight: 600;" id="opponentSpeed">0</span>
              </div>
            </div>

            <!-- Status Effects -->
            <div id="opponentStatusEffects" class="status-effects" style="display: flex; flex-wrap: wrap; gap: 6px; min-height: 28px;">
              <div style="color: #666; font-size: 11px; font-style: italic;">No status effects</div>
            </div>
          </div>

          <!-- Battle Controls -->
          <div style="display: flex; flex-direction: column; gap: 8px; margin-top: auto;">
            <button id="btnSimulate" type="button" title="Run a simulation between the two loadouts" class="battle-button" style="background: linear-gradient(135deg, #0f3 0%, #0a8 100%); color: #000; border: none; border-radius: 8px; padding: 12px; cursor: pointer; font-size: 14px; font-weight: 700; box-shadow: 0 2px 8px rgba(0,255,51,0.3);">‚ñ∂Ô∏è START BATTLE</button>
            <button id="btnClearLog" type="button" title="Clear the simulation log" style="background: #333; color: #fff; border: none; border-radius: 8px; padding: 8px; cursor: pointer; font-size: 12px;">üßπ Clear Log</button>
          </div>
        </div>

        <!-- MIDDLE PANE: Event Log -->
        <div class="event-log-pane" style="display: flex; flex-direction: column; background: #0a0a0a; border: 2px solid #333; border-radius: 12px; overflow: hidden; min-height: 0;">
          
          <!-- Log Header -->
          <div style="background: linear-gradient(90deg, #333 0%, #555 100%); padding: 12px 16px; border-bottom: 2px solid #333; flex-shrink: 0;">
            <div style="display: flex; align-items: center; justify-content: space-between;">
              <h3 style="color: #fff; font-size: 16px; font-weight: 700; margin: 0;">üìú EVENT LOG</h3>
              <div style="display: flex; align-items: center; gap: 12px;">
                <!-- Noise Filter Toggle -->
                <label style="display: flex; align-items: center; gap: 6px; color: #ccc; font-size: 12px;">
                  <input type="checkbox" id="noiseFilterToggle" style="accent-color: #0f3;">
                  Hide noise
                </label>
                <div id="battleStatus" style="color: #ccc; font-size: 12px; font-weight: 600;">Ready</div>
              </div>
            </div>
          </div>
          
          <!-- Timeline Controls -->
          <div id="timelineControls" style="display: none; background: rgba(0,20,0,0.8); border-bottom: 2px solid #0a5; padding: 12px 16px; flex-shrink: 0;">
            <div style="display: flex; align-items: center; justify-content: center; gap: 12px; flex-wrap: wrap;">
              <div style="display: flex; align-items: center; gap: 6px;">
                <button id="replayFirst" class="replay-btn" style="background: #0a5; color: #000; border: none; border-radius: 4px; padding: 6px 8px; cursor: pointer; font-size: 11px; font-weight: 700;">‚èÆÔ∏è</button>
                <button id="replayBack" class="replay-btn" style="background: #0a5; color: #000; border: none; border-radius: 4px; padding: 6px 8px; cursor: pointer; font-size: 11px; font-weight: 700;">&lt;&lt;</button>
                <button id="replayPlay" class="replay-btn" style="background: #0f3; color: #000; border: none; border-radius: 4px; padding: 6px 8px; cursor: pointer; font-size: 11px; font-weight: 700;">‚ñ∂Ô∏è</button>
                <button id="replayForward" class="replay-btn" style="background: #0a5; color: #000; border: none; border-radius: 4px; padding: 6px 8px; cursor: pointer; font-size: 11px; font-weight: 700;">&gt;&gt;</button>
                <button id="replayLast" class="replay-btn" style="background: #0a5; color: #000; border: none; border-radius: 4px; padding: 6px 8px; cursor: pointer; font-size: 11px; font-weight: 700;">‚è≠Ô∏è</button>
              </div>
              <div style="display: flex; align-items: center; gap: 6px; color: #0f3; font-size: 11px;">
                <label>Turn:</label>
                <input id="turnInput" type="number" min="1" value="1" style="width: 50px; background: #000; color: #0f3; border: 1px solid #0a5; border-radius: 4px; padding: 4px 6px; font-size: 11px; text-align: center;">
                <span id="turnTotal">/ 0</span>
              </div>
              <div style="display: flex; align-items: center; gap: 6px; color: #0f3; font-size: 11px;">
                <label>Speed:</label>
                <select id="replaySpeed" style="background: #000; color: #0f3; border: 1px solid #0a5; border-radius: 4px; padding: 2px 4px; font-size: 11px;">
                  <option value="2000">0.5√ó</option>
                  <option value="1000" selected>1√ó</option>
                  <option value="500">2√ó</option>
                  <option value="250">4√ó</option>
                </select>
              </div>
            </div>
          </div>
          
          <!-- Battle Log Content -->
          <div id="simLog" style="flex: 1; overflow-y: auto; padding: 16px; font-size: 14px; color: #ccc; line-height: 1.6; min-height: 0;" aria-live="polite">
            <div style="text-align: center; color: #666; font-style: italic; padding: 40px 20px;">
              <img src="assets/attack.png" style="width: 16px; height: 16px; vertical-align: middle; image-rendering: pixelated;"> Ready to witness epic battles!<br><br>
              Configure your loadouts and hit <strong style="color: #0f3;">"START BATTLE"</strong> to begin.
            </div>
          </div>
        </div>

        <!-- RIGHT PANE: Loadout Tray -->
        <div class="loadout-tray-pane" style="display: flex; flex-direction: column; gap: 16px; background: #0a0a0a; border: 2px solid #333; border-radius: 12px; padding: 16px; overflow-y: auto;">
          <h3 style="color: #fff; margin: 0 0 12px 0; font-size: 16px; text-align: center;">‚öîÔ∏è LOADOUT TRAY</h3>
          
          <!-- Player Loadout -->
          <div class="loadout-section">
            <h4 style="color: #0f3; margin: 0 0 8px 0; font-size: 14px;">Player Items</h4>
            <div id="playerLoadoutDisplay" style="display: flex; flex-direction: column; gap: 8px; min-height: 40px;">
              <div style="color: #666; font-size: 11px; font-style: italic; text-align: center; padding: 12px;">No items equipped</div>
            </div>
          </div>

          <!-- Opponent Loadout -->
          <div class="loadout-section">
            <h4 style="color: #f33; margin: 0 0 8px 0; font-size: 14px;">Opponent Items</h4>
            <div id="opponentLoadoutDisplay" style="display: flex; flex-direction: column; gap: 8px; min-height: 40px;">
              <div style="color: #666; font-size: 11px; font-style: italic; text-align: center; padding: 12px;">No items equipped</div>
            </div>
          </div>

          <!-- Tag Groups (Future Implementation) -->
          <div class="tag-groups" style="display: none;">
            <h4 style="color: #fa0; margin: 12px 0 8px 0; font-size: 14px;">By Category</h4>
            <div class="tag-group" data-tag="Food">
              <div class="tag-header" style="background: #95d5b2; color: #000; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">üçÉ Food</div>
              <div class="tag-items" style="margin-top: 4px; display: flex; flex-wrap: wrap; gap: 4px;"></div>
            </div>
            <!-- More tag groups will be added -->
          </div>
        </div>

      </div>
    </section>
  </div>

  <!-- RIGHT / OPPONENT -->
  <section class="panel" id="panelO">
    <div class="title">Oils</div>
    <div class="oils" id="oilsO">
      <div class="oil" data-kind="attack"><img src="assets/attack.png"><span>Attack Oil</span></div>
      <div class="oil" data-kind="armor"><img src="assets/armor.png"><span>Armor Oil</span></div>
      <div class="oil" data-kind="speed"><img src="assets/speed.png"><span>Speed Oil</span></div>
    </div>
    <div class="weapon-slot" id="weaponO">Drop a Weapon</div>
    <div class="edge-tile">
      <div class="edge-body">
        <img id="edgeOIcon" src="assets/placeholder.png" alt="">
        <select id="edgeO"><option value="">√¢‚Ç¨‚Äù Select Edge √¢‚Ç¨‚Äù</option></select>
      </div>
      <div id="edgeOEffect" class="meta effect"></div>
    </div>
    <div class="selIndicator" id="selOI">Selected: None</div>
    <div class="grid12" id="gridO"></div>
    <div class="stats">
      <div class="stat"><img src="assets/health.png" alt="health"><span id="oH">10</span></div>
      <div class="stat"><img src="assets/attack.png" alt="atk"><span id="oA">0</span></div>
      <div class="stat"><img src="assets/armor.png" alt="arm"><span id="oR">0</span></div>
      <div class="stat"><img src="assets/speed.png" alt="spd"><span id="oS">0</span></div>
    </div>
    <div class="setsBox" id="setsO"></div>
  </section>
</div>

<!-- Simulation panel removed from bottom of page -->

<div id="detailModal">
  <div id="detailBox">
    <button id="detailClose">Close</button>
    <h2 id="detailName"></h2>
    <div id="detailEffect"></div>
    <div id="detailStats"></div>
  </div>
</div>

<!-- Note: details are loaded from details.json via fetch.
     For file:// usage (no local server), we also ship a pre-bundled
     details.js that defines window.HEIC_DETAILS as a fallback. -->
<script src="details.js"></script>
<script src="heic_sim.js"></script>
<script src="heic_effects.js"></script>
<script src="heic_sets.js"></script>

<script>
/* Battle Replay System - Icon Renderer Module */
const BattleIconRenderer = {
  // Map action types and events to icon paths
  ICON_MAP: {
    // Combat actions
    'attack': 'assets/attack.png',
    'hit': 'assets/attack.png',
    'strike': 'assets/attack.png',
    'damage': 'assets/attack.png',
    
    // Healing and recovery
    'heal': 'assets/health.png',
    'regen': 'assets/health.png',
    'recovery': 'assets/health.png',
    
    // Defense
    'armor': 'assets/armor.png',
    'shield': 'assets/armor.png',
    'block': 'assets/armor.png',
    
    // Speed and movement
    'speed': 'assets/speed.png',
    'haste': 'assets/speed.png',
    'slow': 'assets/speed.png',
    
    // Status effects - use item icons when available
    'poison': 'items/poisonous_mushroom/icon.png',
    'thorns': 'items/bramble_vest/icon.png',
    'fire': 'items/cherry_bomb/icon.png',
    'explosion': 'items/cherry_bomb/icon.png',
    
    // Default fallbacks
    'effect': 'assets/placeholder.png',
    'item': 'assets/placeholder.png',
    'weapon': 'assets/attack.png',
    'turn': 'assets/speed.png'
  },
  
  // Extract action type from log text
  getActionFromText(text) {
    const lowerText = text.toLowerCase();
    
    // Check for specific patterns
    if (lowerText.includes('hits') || lowerText.includes('attacks') || lowerText.includes('strikes')) return 'attack';
    if (lowerText.includes('heals') || lowerText.includes('recovers')) return 'heal';
    if (lowerText.includes('gains') && lowerText.includes('armor')) return 'armor';
    if (lowerText.includes('gains') && lowerText.includes('speed')) return 'speed';
    if (lowerText.includes('poison')) return 'poison';
    if (lowerText.includes('thorns')) return 'thorns';
    if (lowerText.includes('explosion') || lowerText.includes('explodes')) return 'explosion';
    if (lowerText.includes('turn') && lowerText.includes('--')) return 'turn';
    
    // Extract item references (::icon:items/name::)
    const iconMatch = lowerText.match(/::icon:(items|weapons)\/([^:]+)::/);
    if (iconMatch) {
      return `${iconMatch[1]}/${iconMatch[2]}/icon.png`;
    }
    
    return 'effect'; // default
  },
  
  // Create icon element for log entry
  createIcon(actionType, fallbackText = '') {
    const iconPath = this.ICON_MAP[actionType] || actionType;
    const img = document.createElement('img');
    img.className = 'log-icon';
    img.src = iconPath;
    img.alt = actionType;
    
    // Fallback to placeholder if icon fails to load
    img.onerror = () => {
      if (img.src !== this.ICON_MAP.effect) {
        img.src = this.ICON_MAP.effect;
      }
    };
    
    return img;
  },
  
  // Render icons for a log entry element
  renderIcons(entryEl, logText) {
    // Remove existing icons
    const existingIcons = entryEl.querySelectorAll('.log-icon');
    existingIcons.forEach(icon => icon.remove());
    
    // Don't add icons to dividers or special entries
    if (entryEl.classList.contains('battle-divider')) return;
    
    const actionType = this.getActionFromText(logText);
    const icon = this.createIcon(actionType, logText);
    
    // Insert icon at the beginning of the entry
    entryEl.insertBefore(icon, entryEl.firstChild);
  }
};
</script>

<script>
/* Battle Replay System - State Manager Module */
const BattleStateManager = {
  logEntries: [],
  stateSnapshots: [],
  battleData: null,
  
  // Initialize with battle result data
  initBattle(simulationResult) {
    this.logEntries = [];
    this.stateSnapshots = [];
    this.battleData = simulationResult;
    
    if (simulationResult.log && Array.isArray(simulationResult.log)) {
      // Process log entries into structured format
      simulationResult.log.forEach((line, index) => {
        if (line && line.trim()) {
          this.logEntries.push({
            index,
            text: line,
            type: this.classifyLogLine(line),
            hp: this.extractHPFromLine(line)
          });
        }
      });
    }
    
    // Create state snapshots (simplified for now)
    this.createStateSnapshots();
  },
  
  // Classify log line type for styling
  classifyLogLine(line) {
    const lineStr = String(line);
    if (lineStr.includes('‚îÅ‚îÅ‚îÅ') || lineStr.includes('BATTLE')) return 'major-divider';
    if (lineStr.match(/^\d+\.\s*--\s*Turn\s+\d+\s*--/)) return 'turn-header';
    if (lineStr.includes('Player') || lineStr.includes('Fighter')) return 'player';
    if (lineStr.includes('Opponent') || lineStr.includes('Enemy')) return 'opponent';
    return 'system';
  },
  
  // Extract HP information from log line
  extractHPFromLine(line) {
    const hpMatch = line.match(/\[PlayerHP:\s*(\d+)\s*\|\s*OpponentHP:\s*(\d+)\]/);
    if (hpMatch) {
      return {
        player: parseInt(hpMatch[1], 10),
        opponent: parseInt(hpMatch[2], 10)
      };
    }
    return null;
  },
  
  // Create state snapshots for each turn
  createStateSnapshots() {
    // For now, create simple snapshots
    // This could be enhanced to capture actual fighter states
    this.logEntries.forEach((entry, index) => {
      this.stateSnapshots.push({
        index,
        turnNumber: this.getTurnNumber(entry.text),
        hp: entry.hp,
        timestamp: Date.now()
      });
    });
  },
  
  // Extract turn number from log text
  getTurnNumber(text) {
    const turnMatch = text.match(/Turn\s+(\d+)/);
    return turnMatch ? parseInt(turnMatch[1], 10) : 0;
  },
  
  // Get log entry by index
  getLogEntry(index) {
    return this.logEntries[index] || null;
  },
  
  // Get state snapshot by index
  getStateSnapshot(index) {
    return this.stateSnapshots[index] || null;
  },
  
  // Get total number of entries
  getTotalEntries() {
    return this.logEntries.length;
  },
  
  // Check if battle data is loaded
  isLoaded() {
    return this.battleData !== null && this.logEntries.length > 0;
  }
};
</script>

<script>
/* Battle Replay System - Replay Controller Module */
const BattleReplayController = {
  currentIndex: 0,
  isPlaying: false,
  playbackSpeed: 1000, // ms between turns
  playbackTimer: null,
  elements: {},
  
  // Initialize replay controller
  init() {
    this.elements = {
      controls: document.getElementById('replayControls'),
      first: document.getElementById('replayFirst'),
      back: document.getElementById('replayBack'),
      play: document.getElementById('replayPlay'),
      forward: document.getElementById('replayForward'),
      last: document.getElementById('replayLast'),
      turnInput: document.getElementById('turnInput'),
      turnTotal: document.getElementById('turnTotal'),
      speedSelect: document.getElementById('replaySpeed'),
      log: document.getElementById('simLog')
    };
    
    this.setupEventListeners();
    this.hide();
  },
  
  // Setup event listeners for controls
  setupEventListeners() {
    if (!this.elements.first) return;
    
    this.elements.first.addEventListener('click', () => this.goToFirst());
    this.elements.back.addEventListener('click', () => this.stepBack());
    this.elements.play.addEventListener('click', () => this.togglePlayback());
    this.elements.forward.addEventListener('click', () => this.stepForward());
    this.elements.last.addEventListener('click', () => this.goToLast());
    
    this.elements.turnInput.addEventListener('change', () => this.goToTurn());
    this.elements.speedSelect.addEventListener('change', () => this.updateSpeed());
    
    // Add keyboard shortcuts
    document.addEventListener('keydown', (e) => this.handleKeyboard(e));
  },
  
  // Handle keyboard shortcuts
  handleKeyboard(e) {
    if (!this.isVisible() || e.target.tagName === 'INPUT') return;
    
    switch(e.key) {
      case 'ArrowLeft':
        e.preventDefault();
        this.stepBack();
        break;
      case 'ArrowRight':
        e.preventDefault();
        this.stepForward();
        break;
      case ' ':
        e.preventDefault();
        this.togglePlayback();
        break;
      case 'Home':
        e.preventDefault();
        this.goToFirst();
        break;
      case 'End':
        e.preventDefault();
        this.goToLast();
        break;
    }
  },
  
  // Initialize replay with battle data
  loadBattle(simulationResult) {
    BattleStateManager.initBattle(simulationResult);
    
    if (!BattleStateManager.isLoaded()) {
      this.hide();
      return;
    }
    
    this.currentIndex = 0;
    this.updateTurnCounter();
    this.renderBattleLog();
    this.show();
    this.updateControls();
  },
  
  // Render the complete battle log with replay features
  renderBattleLog() {
    if (!this.elements.log) return;
    
    this.elements.log.innerHTML = '';
    const totalEntries = BattleStateManager.getTotalEntries();
    
    for (let i = 0; i < totalEntries; i++) {
      const entry = BattleStateManager.getLogEntry(i);
      if (!entry) continue;
      
      const div = document.createElement('div');
      div.className = `battle-log-line ${entry.type}`;
      div.dataset.index = i;
      div.innerHTML = entry.text;
      
      // Add turn marker
      const marker = document.createElement('div');
      marker.className = 'turn-marker';
      div.appendChild(marker);
      
      // Add HP tracker if available
      if (entry.hp) {
        const hpTracker = document.createElement('span');
        hpTracker.className = 'hp-tracker';
        hpTracker.innerHTML = ` [P:${entry.hp.player} | O:${entry.hp.opponent}]`;
        div.appendChild(hpTracker);
      }
      
      // Add click listener for direct navigation
      div.addEventListener('click', () => this.goToIndex(i));
      
      // Render appropriate icon
      BattleIconRenderer.renderIcons(div, entry.text);
      
      this.elements.log.appendChild(div);
    }
    
    // Highlight current entry
    this.highlightCurrentEntry();
  },
  
  // Highlight the current log entry
  highlightCurrentEntry() {
    if (!this.elements.log) return;
    
    // Remove previous highlights
    const previous = this.elements.log.querySelectorAll('.battle-log-line.active');
    previous.forEach(el => el.classList.remove('active'));
    
    // Highlight current entry
    const current = this.elements.log.querySelector(`[data-index="${this.currentIndex}"]`);
    if (current) {
      current.classList.add('active');
      current.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  },
  
  // Navigation methods
  goToFirst() {
    this.currentIndex = 0;
    this.updateView();
  },
  
  goToLast() {
    this.currentIndex = Math.max(0, BattleStateManager.getTotalEntries() - 1);
    this.updateView();
  },
  
  stepBack() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      this.updateView();
    }
  },
  
  stepForward() {
    const total = BattleStateManager.getTotalEntries();
    if (this.currentIndex < total - 1) {
      this.currentIndex++;
      this.updateView();
    }
  },
  
  goToIndex(index) {
    const total = BattleStateManager.getTotalEntries();
    this.currentIndex = Math.max(0, Math.min(total - 1, index));
    this.updateView();
  },
  
  goToTurn() {
    const turnNumber = parseInt(this.elements.turnInput.value, 10) - 1;
    this.goToIndex(turnNumber);
  },
  
  // Playback control
  togglePlayback() {
    if (this.isPlaying) {
      this.stopPlayback();
    } else {
      this.startPlayback();
    }
  },
  
  startPlayback() {
    this.isPlaying = true;
    this.elements.play.textContent = '‚è∏Ô∏è';
    this.elements.play.setAttribute('aria-label', 'Pause auto-play');
    
    this.playbackTimer = setInterval(() => {
      if (this.currentIndex >= BattleStateManager.getTotalEntries() - 1) {
        this.stopPlayback();
        return;
      }
      this.stepForward();
    }, this.playbackSpeed);
  },
  
  stopPlayback() {
    this.isPlaying = false;
    this.elements.play.textContent = '‚ñ∂Ô∏è';
    this.elements.play.setAttribute('aria-label', 'Auto-play battle');
    
    if (this.playbackTimer) {
      clearInterval(this.playbackTimer);
      this.playbackTimer = null;
    }
  },
  
  updateSpeed() {
    this.playbackSpeed = parseInt(this.elements.speedSelect.value, 10);
    
    // Restart playback with new speed if currently playing
    if (this.isPlaying) {
      this.stopPlayback();
      this.startPlayback();
    }
  },
  
  // UI updates
  updateView() {
    this.highlightCurrentEntry();
    this.updateTurnCounter();
    this.updateControls();
  },
  
  updateTurnCounter() {
    const total = BattleStateManager.getTotalEntries();
    this.elements.turnInput.value = this.currentIndex + 1;
    this.elements.turnInput.max = total;
    this.elements.turnTotal.textContent = `/ ${total}`;
  },
  
  updateControls() {
    const total = BattleStateManager.getTotalEntries();
    const isFirst = this.currentIndex === 0;
    const isLast = this.currentIndex >= total - 1;
    
    this.elements.first.disabled = isFirst;
    this.elements.back.disabled = isFirst;
    this.elements.forward.disabled = isLast;
    this.elements.last.disabled = isLast;
  },
  
  // Visibility control
  show() {
    if (this.elements.controls) {
      this.elements.controls.style.display = 'block';
    }
  },
  
  hide() {
    if (this.elements.controls) {
      this.elements.controls.style.display = 'none';
    }
    this.stopPlayback();
  },
  
  isVisible() {
    return this.elements.controls && 
           this.elements.controls.style.display !== 'none';
  },
  
  // Cleanup
  destroy() {
    this.stopPlayback();
    // Remove event listeners if needed
  }
};
</script>

<script>
/* Main builder logic using embedded details data */
let RAW_DATA = {};
let DATA_ARR = [];
async function loadData() {
  try {
    // Merge both sources when available to avoid missing entries.
    // Start with any pre-bundled details (file:// safe).
    RAW_DATA = (window.HEIC_DETAILS && typeof window.HEIC_DETAILS === 'object') ? window.HEIC_DETAILS : {};

    // Try to fetch compiled_details.json first (preferred - contains merged stats)
    try {
      const res = await fetch('compiled_details.json', { cache: 'no-store' });
      if (res.ok) {
        const fromJson = await res.json();
        // Use compiled data as primary source
        RAW_DATA = Object.assign({}, RAW_DATA, fromJson); 
        console.log('‚úÖ Loaded compiled_details.json (pre-merged stats)');
      } else {
        throw new Error('compiled_details.json not found');
      }
    } catch(_compiledErr) {
      // Fallback: try original details.json and do runtime merge
      console.log('‚ö†Ô∏è  Falling back to runtime merge (run npm run build for better performance)');
      try {
        const res = await fetch('details.json', { cache: 'no-store' });
        if (res.ok) {
          const fromJson = await res.json();
          // Prioritize JSON data, but keep JS data as a fallback.
          RAW_DATA = Object.assign({}, RAW_DATA, fromJson); 
        }
      } catch(_fetchErr) {
        // ignore fetch failure (e.g., file://), rely on details.js
      }

      // If using fallback, try to load and merge stats_overrides.json
      try {
        const resO = await fetch('stats_overrides.json', { cache: 'no-store' });
        if (resO.ok) {
          const overrides = await resO.json();
          for (const [k, statObj] of Object.entries(overrides || {})) {
            if (RAW_DATA[k]) {
              const baseStats = RAW_DATA[k].stats || {};
              RAW_DATA[k].stats = Object.assign({}, baseStats, statObj);
            }
          }
        }
      } catch(_overrideErr) {
        // ignore override failure
      }
    }

    try { window.HEIC_DETAILS = RAW_DATA; } catch(_) {}

    // Make data iterable
    DATA_ARR = Object.entries(RAW_DATA).map(([key,val]) => { 
      val.key = key; 
      
      // Set bucket based on the key's prefix
      if (key.startsWith('weapons/')) {
        val.bucket = 'weapons';
      } else if (key.startsWith('items/')) {
        val.bucket = 'items';
      } else if (key.startsWith('upgrades/')) {
        val.bucket = 'upgrades';
      } else if (key.startsWith('sets/')) {
        val.bucket = 'sets';
      }
      
      return val; 
    });
    
    // Count and log the number of items by bucket for verification
    const itemsCount = DATA_ARR.filter(item => item.bucket === 'items').length;
    const weaponsCount = DATA_ARR.filter(item => item.bucket === 'weapons').length;
    const upgradesCount = DATA_ARR.filter(item => item.bucket === 'upgrades').length;
    const setsCount = DATA_ARR.filter(item => item.bucket === 'sets').length;
    const noBucketCount = DATA_ARR.filter(item => !item.bucket).length;
    const totalCount = DATA_ARR.length;
    
    console.log(`Data loaded: ${totalCount} total items`);
    console.log(`  - Items: ${itemsCount}`);
    console.log(`  - Weapons: ${weaponsCount}`);
    console.log(`  - Upgrades: ${upgradesCount}`);
    console.log(`  - Sets: ${setsCount}`);
    console.log(`  - No bucket: ${noBucketCount}`);
    
    // Log first few items to check bucket values
    console.log('Sample items:', DATA_ARR.slice(0, 5).map(item => ({ key: item.key, name: item.name, bucket: item.bucket })));
    
    // Check if RAW_DATA has more entries than DATA_ARR
    const rawDataCount = Object.keys(RAW_DATA).length;
    console.log(`RAW_DATA has ${rawDataCount} entries, DATA_ARR has ${totalCount} entries`);
    
    // Check for items that might not have standard bucket values
    const bucketTypes = {};
    DATA_ARR.forEach(item => {
      const bucket = item.bucket || 'undefined';
      bucketTypes[bucket] = (bucketTypes[bucket] || 0) + 1;
    });
    console.log('All bucket types:', bucketTypes);
    
    // Build a set of keys that support Gold/Diamond tiers either because:
    // - effect text mentions Gold/Diamond, or
    // - sibling variant slugs *_gold or *_diamond exist.
    window.TIERABLE = new Set();
    const keys = Object.keys(RAW_DATA);
    const hasVariant = (slug) => keys.some(k => /^(items|weapons)\//.test(k) && (k.endsWith(slug+"_gold") || k.endsWith(slug+"_diamond")));
    for (const [k, v] of Object.entries(RAW_DATA)){
      if (!v || typeof v !== 'object') continue;
      const eff = (v.effect||'');
      const m = /^(items|weapons)\/(.+)$/.exec(k);
      const baseSlug = m ? m[2] : '';
      if (/gold|diamond/i.test(eff) || hasVariant(baseSlug)) {
        window.TIERABLE.add(k);
      }
    }
    // Populate edge selects once data is ready
    populateEdges();
    // Build empty item grids for both sides
    initSlots();
    // Initialize Advanced Compendium System
    initAdvancedCompendium();
    
    // TEMP: Show all items immediately for debugging
    setTimeout(() => {
      console.log('TEMP: Forcing display of all items');
      const itemGridElement = document.getElementById('itemGrid');
      if (itemGridElement && DATA_ARR && DATA_ARR.length > 0) {
        console.log('TEMP: Found itemGrid and DATA_ARR with', DATA_ARR.length, 'items');
        
        // Clear any existing content
        itemGridElement.innerHTML = '';
        
        // Show first 20 items directly
        DATA_ARR.slice(0, 20).forEach((item, index) => {
          const card = document.createElement('div');
          card.style.cssText = `
            background: #000;
            border: 2px solid #f33;
            border-radius: 16px;
            padding: 14px;
            color: #fff;
            cursor: pointer;
            margin-bottom: 8px;
          `;
          
          card.innerHTML = `
            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
              <img src="${item.key}/icon.png" alt="${item.name}" 
                   style="width: 48px; height: 48px; image-rendering: pixelated;"
                   onerror="this.src='placeholder.png'">
              <div>
                <div style="font-weight: 700; font-size: 18px; color: #f33;">${item.name}</div>
                <div style="font-size: 12px; color: #aaa;">${item.key}</div>
              </div>
            </div>
            <div style="color: #ccc; font-size: 13px;">${item.effect || 'No description'}</div>
          `;
          
          // Add drag functionality
          card.draggable = true;
          card.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', item.key);
          });
          
          itemGridElement.appendChild(card);
        });
        
        // Update the count
        const resultCountElement = document.getElementById('resultCount');
        if (resultCountElement) {
          resultCountElement.textContent = `${DATA_ARR.length} items (temp display)`;
        }
        
        console.log('TEMP: Direct display complete');
      } else {
        console.log('TEMP: itemGrid or DATA_ARR not found');
      }
    }, 500);
    // Compute initial totals for player and opponent (empty builds)
    updateTotals('P');
    updateTotals('O');
  } catch(err) {
    console.error('Error loading details.json', err);
    const msg = document.createElement('div');
    msg.style.color = '#f66';
    msg.style.padding = '8px';
    msg.textContent = 'Failed to load details.json. Please serve files via a local server (e.g., python -m http.server) instead of opening via file://';
    document.body.insertBefore(msg, document.body.firstChild);
  }
}
loadData();

// Initialize Battle Replay System
BattleReplayController.init();

// Icons for stats
const ICONS = { attack:'attack.png', health:'health.png', armor:'armor.png', speed:'speed.png' };

const $ = sel => document.querySelector(sel);

// Advanced Compendium Elements (will be queried when needed)
let globalSearch, searchChips, itemGrid, itemTable, tableBody, compareContainer;
let resultCount, filterSummary, reviewCount, itemDetailModal, itemDetailContent, qaPanel;
let grid, countSpan; // Legacy elements

function getCompendiumElements() {
  if (!globalSearch) {
    globalSearch = $('#globalSearch');
    searchChips = $('#searchChips');
    itemGrid = $('#itemGrid');
    itemTable = $('#itemTable');
    tableBody = $('#tableBody');
    compareContainer = $('#compareContainer');
    resultCount = $('#resultCount');
    filterSummary = $('#filterSummary');
    reviewCount = $('#reviewCount');
    itemDetailModal = $('#itemDetailModal');
    itemDetailContent = $('#itemDetailContent');
    qaPanel = $('#qaPanel');
    
    // Legacy elements for backwards compatibility - try both new and old IDs
    grid = itemGrid || $('#grid'); // Try new first, fallback to old
    countSpan = resultCount || $('#count'); // Try new first, fallback to old
    
    console.log('Elements found:', {
      globalSearch: !!globalSearch,
      itemGrid: !!itemGrid,
      grid: !!grid,
      resultCount: !!resultCount,
      countSpan: !!countSpan
    });
  }
}

// Advanced Compendium State
let compendiumState = {
  searchTerms: [],
  searchQuery: '', // Add this for immediate search
  activeFilters: {
    bucket: new Set(),
    tags: new Set(), 
    triggers: new Set(),
    stats: { attack: 0, armor: 0, health: 0, speed: 0 },
    advanced: new Set()
  },
  viewMode: 'cards',
  currentTier: 'base',
  needsReviewOnly: false,
  sortBy: 'name',
  sortDirection: 'asc',
  compareItems: new Set(),
  qaResults: { lint: [], drift: [] }
};

// Force the bucket selector to "All" to ensure it shows all items by default
bucketSel.value = 'All';
const detailModal = $('#detailModal');
const detailName = $('#detailName');
const detailEffect = $('#detailEffect');
const detailStats = $('#detailStats');
$('#detailClose').addEventListener('click', () => detailModal.style.display='none');
detailModal.addEventListener('click', e => { if (e.target === detailModal) detailModal.style.display='none'; });

// Number of item slots available per side.  Displayed as empty dashed boxes until filled.
const SLOT_COUNT = 12;

// Selection target for slot-aware actions
let activeTarget = { side: null, idx: -1 };

// Player and opponent state
const sides = {
  P: { hpBase:10, atkBase:0, armBase:0, spdBase:0, weapon:null, items:new Array(SLOT_COUNT).fill(null), edge:null, oils:new Set() },
  O: { hpBase:10, atkBase:0, armBase:0, spdBase:0, weapon:null, items:new Array(SLOT_COUNT).fill(null), edge:null, oils:new Set() }
};

function updateTotals(sideKey) {
  const side = sides[sideKey];
  let hp = side.hpBase, atk = side.atkBase, arm = side.armBase, spd = side.spdBase;
  const addStats = obj => {
    if (!obj) return;
    const s = obj.stats || {};
    hp += (s.health || 0);
    atk += (s.attack || 0);
    arm += (s.armor  || 0);
    spd += (s.speed  || 0);
  };
  addStats(side.weapon);
  side.items.forEach(addStats);
  if (side.weapon) {
    if (side.oils.has('attack')) atk += 1;
    if (side.oils.has('armor')) arm += 1;
    if (side.oils.has('speed')) spd += 1;
  }
  const prefix = sideKey === 'P' ? 'p' : 'o';
  $('#'+prefix+'H').textContent = hp;
  $('#'+prefix+'A').textContent = atk;
  $('#'+prefix+'R').textContent = arm;
  $('#'+prefix+'S').textContent = spd;

  // Render set bonuses summary
  try {
    const allSlugs = [];
    if (side.weapon) allSlugs.push(`${side.weapon.bucket}/${side.weapon.slug}`);
    for (const it of side.items) if (it) allSlugs.push(`${it.bucket}/${it.slug}`);
    const defs = (window.HeICSets && window.HeICSets.computeActive) ? window.HeICSets.computeActive(allSlugs) : [];
    const box = sideKey === 'P' ? document.getElementById('setsP') : document.getElementById('setsO');
    if (box) {
      box.innerHTML = '';
      if (!defs || !defs.length) {
        const span = document.createElement('span');
        span.textContent = 'No set bonuses';
        span.style.color = '#f88';
        box.appendChild(span);
      } else {
        defs.forEach(d => {
          const chip = document.createElement('span');
          chip.className = 'setChip';
          const iconSlug = d.effectSlug || (`sets/${d.key}`);
          chip.innerHTML = `<img src="${iconSlug}/icon.png" alt="${d.name}"><span class="name">${d.name}</span><span class="desc">‚Äî ${d.desc}</span>`;
          box.appendChild(chip);
        });
      }
    }
  } catch(_) {}
  
  // Update analysis if currently visible
  if (typeof analysisTab !== 'undefined' && analysisTab && analysisTab.style.display !== 'none') {
    renderAnalysis();
  }

  // Update simulation preview if simulation tab is visible
  if (typeof simulationTab !== 'undefined' && simulationTab && simulationTab.style.display !== 'none') {
    updateSimulationPreview();
  }
}

// Initialise the item slot grids for both player and opponent.  This creates SLOT_COUNT
// placeholder cells with a dashed border.  When items are added later via drag-and-drop
// or the random build function, these placeholders are filled in (the border becomes
// solid and the item name is written in the cell).  Without this, the grids would
// appear empty on page load, which confused some users.
function initSlots() {
  ['P','O'].forEach(sk => {
    const gridEl = sk === 'P' ? $('#gridP') : $('#gridO');
    gridEl.innerHTML = '';
    for (let i = 0; i < SLOT_COUNT; i++) {
      const cell = document.createElement('div');
      cell.className = 'slot';
      cell.dataset.idx = String(i);
      
      cell.addEventListener('click', () => {
        const idx = Number(cell.dataset.idx);
        const side = sides[sk];
        selectSlot(sk, idx);
        if (cell.classList.contains('filled')) {
          side.items[idx] = null;
          cell.classList.remove('filled');
          cell.innerHTML = '';
          updateTotals(sk);
        }
      });
      gridEl.appendChild(cell);
    }
  });
}

// Reset the slots for a single side.  Clears the grid and adds back SLOT_COUNT empty cells.
function resetSlots(sideKey) {
  const gridEl = sideKey === 'P' ? $('#gridP') : $('#gridO');
  gridEl.innerHTML = '';
  for (let i = 0; i < SLOT_COUNT; i++) {
    const cell = document.createElement('div');
    cell.className = 'slot';
    cell.dataset.idx = String(i);
    
    cell.addEventListener('click', () => {
      const idx = Number(cell.dataset.idx);
      const side = sides[sideKey];
      selectSlot(sideKey, idx);
      if (cell.classList.contains('filled')) {
        side.items[idx] = null;
        cell.classList.remove('filled');
        cell.innerHTML = '';
        updateTotals(sideKey);
      }
    });
    gridEl.appendChild(cell);
  }
}

// Highlight selection and track active slot
function selectSlot(sideKey, idx){
  const container = sideKey === 'P' ? $('#gridP') : $('#gridO');
  if (container) {
    container.querySelectorAll('.slot.active').forEach(el => el.classList.remove('active'));
    const el = container.querySelector(`.slot[data-idx="${idx}"]`);
    if (el) { el.classList.add('active'); el.focus(); }
  }
  activeTarget = { side: sideKey, idx };
  updateSelIndicators();
}

// Mini card HTML
function resolveIconCandidates(obj){
  const arr=[];
  if (obj && obj.key) arr.push(`${obj.key}/icon.png`);
  if (obj && obj.bucket && obj.slug) arr.push(`${obj.bucket}/${obj.slug}/icon.png`);
  if (obj && obj.slug){ arr.push(`items/${obj.slug}/icon.png`); arr.push(`weapons/${obj.slug}/icon.png`); }
  return arr;
}

function mini(it){
  const cands = resolveIconCandidates(it);
  const first = cands[0] || 'placeholder.png';
  // inline onerror fallback to keep markup simple
  const onerr = `(function(el){var c=['${(cands.map(c=>c.replace(/"/g,'&quot;'))).join("','")}'];var i=1;el.onerror=function(){if(i<c.length){el.src=c[i++];}else{el.onerror=null;el.src='placeholder.png';}}})(this)`;
  return `<div class="miniCard"><img src="${first}" onerror="${onerr}" alt="${it.name}"><span class="name">${it.name}</span></div>`;
}

function firstEmptyIndex(side){
  const i = side.items.findIndex(x => !x);
  return i === -1 ? 0 : i;
}

// Quick add helpers (used by keyboard nav and UI hooks)
function quickAdd(sideKey, item, tier){
  if (!item) return;
  const side = sides[sideKey];
  if (item.bucket === 'weapons'){
    side.weapon = item;
    const wSlot = sideKey === 'P' ? $('#weaponP') : $('#weaponO');
    if (wSlot) wSlot.innerHTML = mini(item);
    updateTotals(sideKey);
    return;
  }
  if (item.bucket === 'items' || item.bucket === 'upgrades'){
    const idx = firstEmptyIndex(side);
    const annotated = Object.assign({}, item, { tier: tier || 'base' });
    side.items[idx] = annotated;
    const gridEl = sideKey === 'P' ? $('#gridP') : $('#gridO');
    const el = gridEl?.querySelector(`.slot[data-idx="${idx}"]`);
    if (el){ el.innerHTML = mini(item); el.classList.add('filled'); }
    selectSlot(sideKey, idx);
    updateTotals(sideKey);
  }
}

function quickAddToActive(item){
  if (activeTarget.side){
    quickAdd(activeTarget.side, item);
  } else {
    quickAdd('P', item);
  }
}

// Update selected slot labels
function updateSelIndicators(){
  const pi = document.getElementById('selPI');
  const oi = document.getElementById('selOI');
  if (pi) pi.textContent = (activeTarget.side === 'P' && activeTarget.idx >= 0) ? `Selected: P slot ${activeTarget.idx+1}` : 'Selected: None';
  if (oi) oi.textContent = (activeTarget.side === 'O' && activeTarget.idx >= 0) ? `Selected: O slot ${activeTarget.idx+1}` : 'Selected: None';
}

// Clear the currently active slot
function clearActiveSlot(){
  if (!activeTarget.side || activeTarget.idx < 0) return;
  const sideKey = activeTarget.side;
  const idx = activeTarget.idx;
  const side = sides[sideKey];
  if (!side) return;
  side.items[idx] = null;
  const gridEl = sideKey === 'P' ? $('#gridP') : $('#gridO');
  const cell = gridEl?.querySelector(`.slot[data-idx="${idx}"]`);
  if (cell){ cell.classList.remove('filled'); cell.innerHTML = ''; }
  updateTotals(sideKey);
}

// (Delete/Backspace clear shortcut removed as requested)

// (Keyboard shortcuts removed as requested)

function showDetail(entry) {
  detailName.textContent = entry.name;
  detailEffect.textContent = entry.effect || '';
  detailStats.innerHTML = '';
  ['attack','health','armor','speed'].forEach(st => {
    const val = entry.stats && typeof entry.stats[st] === 'number' ? entry.stats[st] : 0;
    const pill = document.createElement('span'); pill.className='pill';
    const pImg = document.createElement('img'); pImg.src = ICONS[st];
    const pTxt = document.createElement('span'); pTxt.textContent = `${st[0].toUpperCase()+st.slice(1)}: ${val}`;
    pill.append(pImg, pTxt);
    detailStats.appendChild(pill);
  });
  detailModal.style.display = 'flex';
}

// =============================================
// ADVANCED COMPENDIUM SYSTEM
// =============================================

// Initialize Advanced Compendium
function initAdvancedCompendium() {
  console.log('Initializing Advanced Compendium...');
  
  // Wait for DOM to be ready
  setTimeout(() => {
    // Ensure elements are available
    getCompendiumElements();
    
    if (!DATA_ARR || !DATA_ARR.length) {
      console.warn('No data available for advanced compendium');
      showNoDataMessage('Compendium data not available. Check details.js or details.json.');
      return;
    }
    
    console.log('DATA_ARR loaded with', DATA_ARR.length, 'items');
    
    // Build filter counts and options
    buildFilterOptions();
    
    // Setup event listeners
    setupCompendiumListeners();
    
    // Initial render
    renderCompendium();
    
    // Run QA analysis
    runQAAnalysis();
    
    console.log('Advanced Compendium initialization complete');
  }, 100);
}

// Build dynamic filter options with counts
function buildFilterOptions() {
  const bucketCounts = new Map();
  const tagCounts = new Map();  
  const triggerCounts = new Map();
  
  DATA_ARR.forEach(item => {
    // Count buckets
    const bucket = item.bucket || 'unknown';
    bucketCounts.set(bucket, (bucketCounts.get(bucket) || 0) + 1);
    
    // Count tags
    if (item.tags) {
      item.tags.forEach(tag => {
        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
      });
    }
    
    // Count triggers (from effects)
    if (item.effects && Array.isArray(item.effects)) {
      item.effects.forEach(effect => {
        if (effect.trigger) {
          triggerCounts.set(effect.trigger, (triggerCounts.get(effect.trigger) || 0) + 1);
        }
      });
    }
  });
  
  // Update bucket filter options
  const bucketFilters = $('#bucketFilters');
  if (bucketFilters) {
    bucketFilters.innerHTML = '';
    ['items', 'weapons', 'sets', 'upgrades'].forEach(bucket => {
      const count = bucketCounts.get(bucket) || 0;
      const label = document.createElement('label');
      label.innerHTML = `<input type="checkbox" value="${bucket}"> <span class="filter-count">(${count})</span> ${bucket.charAt(0).toUpperCase() + bucket.slice(1)}`;
      bucketFilters.appendChild(label);
    });
  }
  
  // Update trigger filter options
  const triggerFilters = $('#triggerFilters');
  if (triggerFilters) {
    triggerFilters.innerHTML = '';
    const commonTriggers = ['battleStart', 'turnStart', 'onHit', 'onWounded', 'onExposed', 'countdown', 'passive'];
    commonTriggers.forEach(trigger => {
      const count = triggerCounts.get(trigger) || 0;
      const label = document.createElement('label');
      const displayName = trigger.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
      label.innerHTML = `<input type="checkbox" value="${trigger}"> <span class="filter-count">(${count})</span> ${displayName}`;
      triggerFilters.appendChild(label);
    });
  }
}

// Setup event listeners for all compendium controls
function setupCompendiumListeners() {
  console.log('Setting up compendium listeners...');
  
  // Ensure elements are available
  getCompendiumElements();
  
  // Search input
  if (globalSearch) {
    globalSearch.addEventListener('input', debounce(handleSearch, 300));
    globalSearch.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        handleSearchSubmit();
      }
    });
    console.log('Search listeners set up');
  } else {
    console.warn('globalSearch element not found');
  }
  
  // View mode switchers
  document.querySelectorAll('.view-mode').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.view-mode').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      compendiumState.viewMode = btn.dataset.mode;
      renderCompendium();
    });
  });
  console.log('View mode listeners set up');
  
  // Tier switchers
  document.querySelectorAll('.tier-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tier-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      compendiumState.currentTier = btn.dataset.tier;
      renderCompendium();
    });
  });
  console.log('Tier switchers set up');
  
  // Needs review toggle
  const needsReviewToggle = document.getElementById('needsReviewToggle');
  if (needsReviewToggle) {
    needsReviewToggle.addEventListener('click', () => {
      compendiumState.needsReviewOnly = !compendiumState.needsReviewOnly;
      needsReviewToggle.classList.toggle('active', compendiumState.needsReviewOnly);
      renderCompendium();
    });
  }
  
  // Quick actions
  const randBuildBtn = document.getElementById('randBuildBtn');
  const randEnemyBtn = document.getElementById('randEnemyBtn');
  const showSimBtn = document.getElementById('showSimBtn');
  
  if (randBuildBtn) randBuildBtn.addEventListener('click', () => randomizeSide('P'));
  if (randEnemyBtn) randEnemyBtn.addEventListener('click', () => randomizeSide('O'));
  if (showSimBtn) showSimBtn.addEventListener('click', () => switchToTab('simulation'));
  
  console.log('Quick action listeners set up');
}

// Handle search input with chips
function handleSearch() {
  const query = globalSearch.value.trim();
  compendiumState.searchQuery = query;
  renderCompendium();
}

function handleSearchSubmit() {
  const query = globalSearch.value.trim();
  if (query && !compendiumState.searchTerms.includes(query)) {
    compendiumState.searchTerms.push(query);
    globalSearch.value = '';
    updateSearchChips();
    renderCompendium();
  }
}

function updateSearchChips() {
  if (!searchChips) return;
  
  searchChips.innerHTML = '';
  compendiumState.searchTerms.forEach((term, index) => {
    const chip = document.createElement('div');
    chip.className = 'search-chip';
    chip.innerHTML = `${term} <span class="remove">√ó</span>`;
    chip.querySelector('.remove').addEventListener('click', () => {
      compendiumState.searchTerms.splice(index, 1);
      updateSearchChips();
      renderCompendium();
    });
    searchChips.appendChild(chip);
  });
}

// Handle filter changes
function handleFilterChange(e) {
  const input = e.target;
  const value = input.value;
  
  if (input.closest('#bucketFilters')) {
    if (input.checked) {
      compendiumState.activeFilters.bucket.add(value);
    } else {
      compendiumState.activeFilters.bucket.delete(value);
    }
  } else if (input.closest('#tagFilters')) {
    if (input.checked) {
      compendiumState.activeFilters.tags.add(value);
    } else {
      compendiumState.activeFilters.tags.delete(value);
    }
  } else if (input.closest('#triggerFilters')) {
    if (input.checked) {
      compendiumState.activeFilters.triggers.add(value);
    } else {
      compendiumState.activeFilters.triggers.delete(value);
    }
  }
  
  renderCompendium();
}

// Main render function for the compendium
function renderCompendium() {
  console.log('renderCompendium called');
  
  // Ensure elements are available
  getCompendiumElements();
  
  if (!DATA_ARR || !DATA_ARR.length) {
    console.warn('No DATA_ARR available, DATA_ARR length:', DATA_ARR ? DATA_ARR.length : 'undefined');
    showNoDataMessage('Compendium data not available. Check details.js or details.json.');
    return;
  }
  
  console.log('Rendering compendium with', DATA_ARR.length, 'total items');
  console.log('Current filters:', compendiumState.activeFilters);
  console.log('Search query:', compendiumState.searchQuery);
  console.log('Search terms:', compendiumState.searchTerms);
  
  // Filter items based on current state
  const filteredItems = filterItems(DATA_ARR);
  console.log('Filtered to', filteredItems.length, 'items');
  
  // Update result count
  updateResultCount(filteredItems.length);
  
  // Render based on view mode
  if (compendiumState.viewMode === 'cards') {
    renderCardsView(filteredItems);
  } else if (compendiumState.viewMode === 'table') {
    renderTableView(filteredItems);
  } else if (compendiumState.viewMode === 'compare') {
    renderCompareView();
  }
  
  // Update review count
  updateReviewCount();
}

// Filter items based on current compendium state
function filterItems(items) {
  console.log('Filtering', items.length, 'total items');
  
  return items.filter(item => {
    // Search terms filter - only filter if there are search terms
    if (compendiumState.searchTerms.length > 0 || (compendiumState.searchQuery && compendiumState.searchQuery.trim())) {
      const searchText = `${item.name} ${item.effect || ''} ${item.key} ${(item.tags || []).join(' ')}`.toLowerCase();
      
      const queryMatch = !compendiumState.searchQuery || !compendiumState.searchQuery.trim() || 
        searchText.includes(compendiumState.searchQuery.toLowerCase());
      const termsMatch = compendiumState.searchTerms.length === 0 || 
        compendiumState.searchTerms.every(term => searchText.includes(term.toLowerCase()));
        
      if (!queryMatch || !termsMatch) return false;
    }
    
    // Bucket filter - only filter if buckets are selected
    if (compendiumState.activeFilters.bucket.size > 0) {
      if (!compendiumState.activeFilters.bucket.has(item.bucket)) return false;
    }
    
    // Tag filter - only filter if tags are selected
    if (compendiumState.activeFilters.tags.size > 0) {
      if (!item.tags || !item.tags.some(tag => compendiumState.activeFilters.tags.has(tag))) return false;
    }
    
    // Trigger filter - only filter if triggers are selected
    if (compendiumState.activeFilters.triggers.size > 0) {
      const itemTriggers = new Set();
      if (item.effects && Array.isArray(item.effects)) {
        item.effects.forEach(effect => {
          if (effect.trigger) itemTriggers.add(effect.trigger);
        });
      }
      if (!Array.from(compendiumState.activeFilters.triggers).some(trigger => itemTriggers.has(trigger))) return false;
    }
    
    // Stat filters - only filter if stat minimums are set > 0
    if (item.stats) {
      for (const [stat, minValue] of Object.entries(compendiumState.activeFilters.stats)) {
        if (minValue > 0 && (item.stats[stat] || 0) < minValue) return false;
      }
    }
    
    // Advanced filters - only filter if advanced options are selected
    if (compendiumState.activeFilters.advanced.has('hasTieredValues')) {
      if (!window.TIERABLE || !window.TIERABLE.has(item.key)) return false;
    }
    
    if (compendiumState.activeFilters.advanced.has('hasConditions')) {
      let hasConditions = false;
      if (item.effects && Array.isArray(item.effects)) {
        hasConditions = item.effects.some(effect => 
          effect.actions && effect.actions.some(action => action.condition)
        );
      }
      if (!hasConditions) return false;
    }
    
    if (compendiumState.activeFilters.advanced.has('firstTurnOnly')) {
      let isFirstTurnOnly = false;
      if (item.effects && Array.isArray(item.effects)) {
        isFirstTurnOnly = item.effects.some(effect => 
          effect.trigger === 'battleStart' || effect.trigger === 'preBattle'
        );
      }
      if (!isFirstTurnOnly) return false;
    }
    
    // Needs review filter - only filter if enabled
    if (compendiumState.needsReviewOnly) {
      const hasIssues = getItemIssues(item).length > 0;
      if (!hasIssues) return false;
    }
    
    return true;
  });
}

// Render cards view
function renderCardsView(items) {
  console.log('renderCardsView called with', items.length, 'items');
  
  // Ensure elements are available
  getCompendiumElements();
  
  // Use either the new itemGrid or fall back to any available grid
  const targetGrid = itemGrid || grid || $('#grid');
  
  if (!targetGrid) {
    console.error('No grid element found! Checked itemGrid, grid, and #grid');
    // Try to find any element that might work
    const fallback = document.querySelector('.item-grid, .grid, [id*="grid"], [class*="grid"]');
    console.log('Fallback element found:', !!fallback, fallback);
    if (fallback) {
      fallback.innerHTML = '<div style="color: #f33; padding: 20px;">Advanced compendium system needs debugging - grid element issue</div>';
    }
    return;
  }
  
  console.log('Using grid element:', targetGrid.id || targetGrid.className);
  
  // Sort items
  const sortedItems = sortItems(items);
  
  targetGrid.innerHTML = '';
  
  if (sortedItems.length === 0) {
    targetGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #666; padding: 40px;">No items match current filters</div>';
    return;
  }
  
  console.log('Creating cards for', sortedItems.length, 'items');
  
  sortedItems.forEach((item, index) => {
    console.log(`Creating card ${index + 1}:`, item.name);
    const card = createItemCard(item);
    targetGrid.appendChild(card);
  });
  
  console.log('Cards rendered successfully');
}

// Create an enhanced item card
function createItemCard(item) {
  const card = document.createElement('div');
  card.className = 'card';
  card.dataset.key = item.key;
  card.draggable = true;
  
  // Add tier data
  card.dataset.tier = compendiumState.currentTier;
  
  // Card styling
  card.style.background = '#000';
  card.style.border = '2px solid #f33';
  card.style.borderRadius = '16px';
  card.style.padding = '14px';
  card.style.color = '#fff';
  card.style.cursor = 'pointer';
  card.style.transition = 'all 0.2s ease';
  
  // Special styling for weapons
  if (item.bucket === 'weapons') {
    card.style.borderColor = '#ff9900';
  }
  
  // Create card content
  card.innerHTML = `
    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
      <img src="${getItemIconPath(item)}" alt="${item.name}" 
           style="width: 48px; height: 48px; image-rendering: pixelated;"
           onerror="this.src='placeholder.png'">
      <div style="flex: 1;">
        <div style="font-weight: 700; font-size: 18px; color: #f33; margin-bottom: 4px;">${item.name}</div>
        <div style="font-size: 12px; color: #aaa;">${item.key}</div>
        ${getItemIssues(item).length > 0 ? '<div class="issue-badges" style="margin-top: 4px;"></div>' : ''}
      </div>
      ${window.TIERABLE && window.TIERABLE.has(item.key) ? 
        `<select class="tier-selector" style="background: #1b1216; color: #f33; border: 1px solid #f33; border-radius: 8px; padding: 2px 6px; font-size: 12px;">
          <option value="base">Base</option>
          <option value="gold">Gold</option>
          <option value="diamond">Diamond</option>
        </select>` : ''
      }
    </div>
    
    <div style="color: #ccc; font-size: 13px; margin-bottom: 12px; min-height: 40px;">
      ${item.effect || 'No description available'}
    </div>
    
    <div style="height: 3px; background: #f33; margin: 8px 0; border-radius: 2px;"></div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
      ${createStatPills(item.stats)}
    </div>
    
    ${(item.tags && item.tags.length > 0) ? `
      <div style="margin-top: 12px; display: flex; flex-wrap: wrap; gap: 4px;">
        ${item.tags.map(tag => `<span class="tag-chip" style="background: rgba(52, 152, 219, 0.2); color: #3498db; padding: 2px 6px; border-radius: 10px; font-size: 11px;">${tag}</span>`).join('')}
      </div>
    ` : ''}
  `;
  
  // Add issue badges if any
  const issueContainer = card.querySelector('.issue-badges');
  if (issueContainer) {
    const issues = getItemIssues(item);
    issues.forEach(issue => {
      const badge = document.createElement('span');
      badge.className = 'issue-badge';
      badge.style.cssText = 'background: #e74c3c; color: white; padding: 2px 6px; border-radius: 8px; font-size: 10px; margin-right: 4px;';
      badge.textContent = issue.type;
      badge.title = issue.message;
      issueContainer.appendChild(badge);
    });
  }
  
  // Event listeners
  card.addEventListener('click', () => showItemDetail(item));
  card.addEventListener('dragstart', (e) => {
    e.dataTransfer.setData('text/plain', item.key);
    try {
      e.dataTransfer.setData('application/json', JSON.stringify({ 
        key: item.key, 
        tier: card.dataset.tier || 'base' 
      }));
    } catch(_) {}
  });
  
  // Tier selector
  const tierSelector = card.querySelector('.tier-selector');
  if (tierSelector) {
    tierSelector.value = compendiumState.currentTier;
    tierSelector.addEventListener('click', (e) => e.stopPropagation());
    tierSelector.addEventListener('change', () => {
      card.dataset.tier = tierSelector.value;
    });
  }
  
  return card;
}

// Create stat pills for an item
function createStatPills(stats) {
  const statOrder = [
    { key: 'attack', label: 'ATK', icon: 'attack.png', color: '#f33' },
    { key: 'armor', label: 'ARM', icon: 'armor.png', color: '#3af' },
    { key: 'health', label: 'HP', icon: 'health.png', color: '#95d5b2' },
    { key: 'speed', label: 'SPD', icon: 'speed.png', color: '#ffd166' }
  ];
  
  return statOrder.map(stat => {
    const value = stats && typeof stats[stat.key] === 'number' ? stats[stat.key] : 0;
    return `
      <div style="display: flex; align-items: center; gap: 6px; background: #210; border: 1px solid ${stat.color}; border-radius: 12px; padding: 6px 10px;">
        <img src="${stat.icon}" style="width: 16px; height: 16px; image-rendering: pixelated;">
        <span style="color: ${stat.color}; font-size: 14px; font-weight: bold;">${value}</span>
      </div>
    `;
  }).join('');
}

// Get appropriate icon path for an item
function getItemIconPath(item) {
  if (item.key) return `${item.key}/icon.png`;
  if (item.bucket && item.slug) return `${item.bucket}/${item.slug}/icon.png`;
  if (item.slug) return `items/${item.slug}/icon.png`;
  return 'placeholder.png';
}

// Get issues for QA analysis
function getItemIssues(item) {
  const issues = [];
  
  // Check for missing required fields
  if (!item.name || item.name.trim() === '') {
    issues.push({ type: 'Missing Name', message: 'Item has no name' });
  }
  
  if (!item.effect || item.effect.trim() === '') {
    issues.push({ type: 'No Description', message: 'Item has no effect description' });
  }
  
  // Check for malformed effects
  if (item.effects && Array.isArray(item.effects)) {
    item.effects.forEach((effect, idx) => {
      if (!effect.trigger) {
        issues.push({ type: 'Bad Effect', message: `Effect ${idx + 1} missing trigger` });
      }
      if (!effect.actions || !Array.isArray(effect.actions)) {
        issues.push({ type: 'Bad Effect', message: `Effect ${idx + 1} missing actions` });
      }
    });
  }
  
  return issues;
}

// Show detailed item modal
function showItemDetail(item) {
  if (!itemDetailModal || !itemDetailContent) return;
  
  itemDetailContent.innerHTML = createItemDetailHTML(item);
  itemDetailModal.style.display = 'block';
}

// Create detailed HTML for item modal
function createItemDetailHTML(item) {
  return `
    <div style="padding: 24px;">
      <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 24px;">
        <img src="${getItemIconPath(item)}" alt="${item.name}" 
             style="width: 64px; height: 64px; image-rendering: pixelated;"
             onerror="this.src='placeholder.png'">
        <div>
          <h2 style="margin: 0 0 8px 0; color: #f33; font-size: 24px;">${item.name}</h2>
          <div style="color: #aaa; font-size: 14px;">${item.key}</div>
          <div style="color: #aaa; font-size: 12px; margin-top: 4px;">
            Type: ${item.bucket || 'Unknown'} | Tags: ${(item.tags || []).join(', ') || 'None'}
          </div>
        </div>
      </div>
      
      <div style="margin-bottom: 24px;">
        <h3 style="color: #fff; margin-bottom: 12px;">Description</h3>
        <div style="color: #ccc; line-height: 1.5;">${item.effect || 'No description available'}</div>
      </div>
      
      <div style="margin-bottom: 24px;">
        <h3 style="color: #fff; margin-bottom: 12px;">Stats</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px;">
          ${createStatPills(item.stats)}
        </div>
      </div>
      
      ${item.effects && item.effects.length > 0 ? `
        <div style="margin-bottom: 24px;">
          <h3 style="color: #fff; margin-bottom: 12px;">Effects</h3>
          <div style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 16px;">
            <pre style="color: #ccc; font-size: 12px; margin: 0; white-space: pre-wrap;">${JSON.stringify(item.effects, null, 2)}</pre>
          </div>
        </div>
      ` : ''}
      
      <div style="display: flex; gap: 12px; justify-content: flex-end;">
        <button onclick="addItemToCompare('${item.key}')" style="background: #3498db; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
          Add to Compare
        </button>
        <button onclick="copyItemData('${item.key}')" style="background: #95a5a6; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
          Copy Data
        </button>
      </div>
    </div>
  `;
}

// Sort items based on current sort settings
function sortItems(items) {
  return [...items].sort((a, b) => {
    let aVal, bVal;
    
    switch (compendiumState.sortBy) {
      case 'name':
        aVal = a.name || '';
        bVal = b.name || '';
        break;
      case 'bucket':
        aVal = a.bucket || '';
        bVal = b.bucket || '';
        break;
      case 'tags':
        aVal = (a.tags || []).join(', ');
        bVal = (b.tags || []).join(', ');
        break;
      case 'tiered':
        aVal = window.TIERABLE && window.TIERABLE.has(a.key) ? 1 : 0;
        bVal = window.TIERABLE && window.TIERABLE.has(b.key) ? 1 : 0;
        break;
      default:
        aVal = a.name || '';
        bVal = b.name || '';
    }
    
    let result = 0;
    if (typeof aVal === 'string' && typeof bVal === 'string') {
      result = aVal.localeCompare(bVal);
    } else {
      result = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
    }
    
    return compendiumState.sortDirection === 'desc' ? -result : result;
  });
}

// Update result count display
function updateResultCount(count) {
  if (resultCount) {
    resultCount.textContent = `${count} items`;
  }
  
  // Update legacy counter for backwards compatibility
  if (countSpan) {
    countSpan.textContent = `Shown: ${count}`;
  }
}

// Update review count
function updateReviewCount() {
  if (!reviewCount) return;
  
  let totalIssues = 0;
  if (DATA_ARR) {
    DATA_ARR.forEach(item => {
      totalIssues += getItemIssues(item).length;
    });
  }
  
  reviewCount.textContent = totalIssues;
  reviewCount.parentElement.style.display = totalIssues > 0 ? 'flex' : 'none';
}

// Run QA analysis
function runQAAnalysis() {
  // This would perform comprehensive QA checks
  compendiumState.qaResults.lint = [];
  compendiumState.qaResults.drift = [];
  
  if (DATA_ARR) {
    DATA_ARR.forEach(item => {
      const issues = getItemIssues(item);
      issues.forEach(issue => {
        compendiumState.qaResults.lint.push({
          item: item.key,
          ...issue
        });
      });
    });
  }
}

// Utility functions
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

function showNoDataMessage(message) {
  console.log('showNoDataMessage called:', message);
  getCompendiumElements();
  
  // Try multiple fallback strategies to show the message
  const gridsToTry = [itemGrid, grid, $('#itemGrid'), $('#grid'), $('.item-grid'), $('.grid')];
  let messageShown = false;
  
  for (let targetGrid of gridsToTry) {
    if (targetGrid && targetGrid.innerHTML !== undefined) {
      targetGrid.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; color: #f33; padding: 40px; background: rgba(255,51,51,0.1); border: 1px solid #f33; border-radius: 8px;">${message}</div>`;
      messageShown = true;
      console.log('Message shown in element:', targetGrid.id || targetGrid.className || 'unnamed');
      break;
    }
  }
  
  if (!messageShown) {
    console.error('Could not find any grid element to show error message');
    // Last resort - try to find any container in the compendium area
    const compendiumMain = document.querySelector('.content-main, .compendium-main, #compendiumTab');
    if (compendiumMain) {
      const errorDiv = document.createElement('div');
      errorDiv.style.cssText = 'text-align: center; color: #f33; padding: 40px; background: rgba(255,51,51,0.1); border: 1px solid #f33; border-radius: 8px; margin: 20px;';
      errorDiv.textContent = message;
      compendiumMain.appendChild(errorDiv);
      console.log('Emergency message shown in compendium main');
    }
  }
}

// Emergency fallback renderer
function renderBasicFallback(container, items) {
  console.log('Running basic fallback renderer with', items.length, 'items');
  
  container.innerHTML = '';
  
  items.forEach(item => {
    const card = document.createElement('div');
    card.style.cssText = `
      background: #000;
      border: 2px solid #f33;
      border-radius: 16px;
      padding: 14px;
      margin: 8px;
      color: #fff;
      cursor: pointer;
    `;
    
    card.innerHTML = `
      <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
        <img src="${item.key}/icon.png" alt="${item.name}" 
             style="width: 48px; height: 48px; image-rendering: pixelated;"
             onerror="this.src='placeholder.png'">
        <div>
          <div style="font-weight: 700; font-size: 18px; color: #f33;">${item.name}</div>
          <div style="font-size: 12px; color: #aaa;">${item.key}</div>
        </div>
      </div>
      <div style="color: #ccc; font-size: 13px;">${item.effect || 'No description'}</div>
    `;
    
    // Add drag functionality
    card.draggable = true;
    card.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/plain', item.key);
    });
    
    container.appendChild(card);
  });
  
  console.log('Basic fallback rendering complete');
}

// Backwards compatibility - keep old renderGrid function name
function renderGrid() {
  try {
    renderCompendium();
  } catch (error) {
    console.error('renderCompendium failed, using fallback:', error);
    const anyGrid = document.querySelector('#itemGrid, .item-grid, #grid, .grid');
    if (anyGrid && DATA_ARR && DATA_ARR.length > 0) {
      renderBasicFallback(anyGrid, DATA_ARR);
    }
  }
}

// Additional helper functions for compendium

function addItemToCompare(key) {
  compendiumState.compareItems.add(key);
  if (compendiumState.compareItems.size >= 2) {
    // Switch to compare view
    document.querySelectorAll('.view-mode').forEach(btn => btn.classList.remove('active'));
    document.querySelector('[data-mode="compare"]')?.classList.add('active');
    compendiumState.viewMode = 'compare';
    renderCompendium();
  }
}

function copyItemData(key) {
  const item = RAW_DATA[key];
  if (item) {
    navigator.clipboard.writeText(JSON.stringify(item, null, 2)).then(() => {
      console.log('Item data copied to clipboard');
    }).catch(err => {
      console.error('Failed to copy item data', err);
    });
  }
}

function renderTableView(items) {
  if (!itemTable || !tableBody) return;
  
  // Show table view
  document.querySelectorAll('.content-view').forEach(view => view.style.display = 'none');
  document.getElementById('tableView').style.display = 'block';
  
  const sortedItems = sortItems(items);
  
  tableBody.innerHTML = '';
  
  sortedItems.forEach(item => {
    const row = document.createElement('tr');
    row.style.cursor = 'pointer';
    row.addEventListener('click', () => showItemDetail(item));
    
    const triggers = new Set();
    if (item.effects && Array.isArray(item.effects)) {
      item.effects.forEach(effect => {
        if (effect.trigger) triggers.add(effect.trigger);
      });
    }
    
    const statString = item.stats ? 
      `ATK:${item.stats.attack || 0} ARM:${item.stats.armor || 0} HP:${item.stats.health || 0} SPD:${item.stats.speed || 0}` : 
      'No stats';
    
    const issues = getItemIssues(item);
    const issuesString = issues.length > 0 ? 
      issues.map(issue => issue.type).join(', ') : 
      'None';
    
    row.innerHTML = `
      <td>${item.name || 'Unnamed'}</td>
      <td>${item.bucket || 'Unknown'}</td>
      <td>${(item.tags || []).join(', ') || 'None'}</td>
      <td>${Array.from(triggers).join(', ') || 'None'}</td>
      <td>${statString}</td>
      <td>TODO: Status effects</td>
      <td>${window.TIERABLE && window.TIERABLE.has(item.key) ? '‚úì' : ''}</td>
      <td style="color: ${issues.length > 0 ? '#e74c3c' : '#27ae60'};">${issuesString}</td>
    `;
    
    tableBody.appendChild(row);
  });
}

function renderCompareView() {
  if (!compareContainer) return;
  
  // Show compare view
  document.querySelectorAll('.content-view').forEach(view => view.style.display = 'none');
  document.getElementById('compareView').style.display = 'block';
  
  const selectedItems = Array.from(compendiumState.compareItems)
    .map(key => RAW_DATA[key])
    .filter(Boolean);
  
  compareContainer.innerHTML = '';
  
  if (selectedItems.length === 0) {
    compareContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 40px;">Select items from cards or table to compare</div>';
    return;
  }
  
  selectedItems.forEach(item => {
    const compareCard = document.createElement('div');
    compareCard.style.cssText = `
      background: rgba(255,255,255,0.05);
      border: 2px solid #f33;
      border-radius: 12px;
      padding: 20px;
      position: relative;
    `;
    
    compareCard.innerHTML = `
      <button onclick="removeFromCompare('${item.key}')" style="
        position: absolute;
        top: 10px;
        right: 10px;
        background: #e74c3c;
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        cursor: pointer;
        font-size: 12px;
      ">√ó</button>
      
      <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
        <img src="${getItemIconPath(item)}" alt="${item.name}" 
             style="width: 48px; height: 48px; image-rendering: pixelated;"
             onerror="this.src='placeholder.png'">
        <div>
          <h3 style="margin: 0; color: #f33;">${item.name}</h3>
          <div style="color: #aaa; font-size: 12px;">${item.key}</div>
        </div>
      </div>
      
      <div style="color: #ccc; margin-bottom: 16px; font-size: 13px;">
        ${item.effect || 'No description'}
      </div>
      
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
        ${createStatPills(item.stats)}
      </div>
      
      ${(item.tags && item.tags.length > 0) ? `
        <div style="margin-top: 12px;">
          <strong style="color: #fff;">Tags:</strong>
          <div style="margin-top: 4px;">${item.tags.map(tag => `<span style="background: rgba(52,152,219,0.2); color: #3498db; padding: 2px 6px; border-radius: 8px; font-size: 11px; margin-right: 4px;">${tag}</span>`).join('')}</div>
        </div>
      ` : ''}
    `;
    
    compareContainer.appendChild(compareCard);
  });
}

function removeFromCompare(key) {
  compendiumState.compareItems.delete(key);
  renderCompendium();
}

function switchToTab(tabName) {
  // Switch to simulation tab
  if (tabName === 'simulation') {
    document.querySelectorAll('.tabBtn').forEach(btn => {
      btn.classList.remove('active');
      if (btn.textContent.toLowerCase().includes('simulation')) {
        btn.classList.add('active');
      }
    });
    
    document.querySelectorAll('section[id$="Tab"]').forEach(section => {
      section.style.display = 'none';
    });
    
    const simTab = document.getElementById('simulationTab');
    if (simTab) {
      simTab.style.display = 'flex';
    }
  }
}

// Drag and drop helpers
function setupDrop(zoneSel, sideKey, type) {
  const zone = $(zoneSel);
  zone.addEventListener('dragover', e=>{ e.preventDefault(); zone.classList.add('drag-over'); });
  zone.addEventListener('dragleave', ()=> zone.classList.remove('drag-over'));
  zone.addEventListener('drop', e => {
    e.preventDefault(); zone.classList.remove('drag-over');
    const key = e.dataTransfer.getData('text/plain');
    let tier = 'base';
    try { const j = e.dataTransfer.getData('application/json'); if (j) { const obj = JSON.parse(j); if (obj && obj.tier) tier = obj.tier; } } catch(_){}
    const item = RAW_DATA[key];
    if (!item) return;
    const side = sides[sideKey];
  if (type === 'weapon') {
      // Only accept weapons in the weapon slot.  Replace any existing weapon.
      if (item.bucket !== 'weapons') return;
      side.weapon = item;

  zone.innerHTML = mini(item);

    } else if (type === 'items') {
      // Only accept items in the item grid.  Do not allow duplicates and do not exceed SLOT_COUNT.
      if (item.bucket !== 'items') return;
      // Determine the intended slot
      let slotEl = e.target.closest('.slot');
      let idx = -1;
      if (slotEl && zone.contains(slotEl)) {
        idx = Number(slotEl.dataset.idx);
      } else {
        idx = side.items.findIndex(x => !x);
        if (idx === -1) idx = 0; // replace first if full
        slotEl = zone.querySelector(`.slot[data-idx="${idx}"]`);
      }
      const annotated = Object.assign({}, item, { tier });
      side.items[idx] = annotated;
      if (slotEl) {
  slotEl.innerHTML = mini(item);
        slotEl.classList.add('filled');
        selectSlot(sideKey, idx);
      }
    }
    updateTotals(sideKey);
  });
}
setupDrop('#weaponP','P','weapon');
setupDrop('#gridP','P','items');
setupDrop('#weaponO','O','weapon');
setupDrop('#gridO','O','items');

// Oils toggles
function setupOils(sel, sideKey) {
  $(sel).querySelectorAll('.oil').forEach(el => {
    el.addEventListener('click', () => {
      const kind = el.dataset.kind;
      const side = sides[sideKey];
      if (side.oils.has(kind)) {
        side.oils.delete(kind);
        el.classList.remove('active');
      } else {
        side.oils.add(kind);
        el.classList.add('active');
      }
      updateTotals(sideKey);
    });
  });
}
setupOils('#oilsP','P');
setupOils('#oilsO','O');

// Populate edge selects after data loaded
function populateEdges() {
  const edges = DATA_ARR.filter(e => e.bucket === 'upgrades' && /edge/i.test(e.slug) && !(/_used$/i.test(e.slug) || /_darkened$/i.test(e.slug)));
  const selects = [$('#edgeP'), $('#edgeO')];
  const effects  = [$('#edgePEffect'), $('#edgeOEffect')];
  const icons    = [$('#edgePIcon'), $('#edgeOIcon')];
  selects.forEach((sel, idx) => {
    // Clear existing options except the first placeholder
    while (sel.options.length > 1) sel.remove(1);
    edges.forEach(e => {
      const opt = document.createElement('option');
      opt.value = e.slug;
      opt.textContent = e.name;
      sel.appendChild(opt);
    });
    // When the user changes the selected edge, update the underlying state, effect text
    // and the displayed icon.  If no edge is selected, fall back to the placeholder icon.
    sel.addEventListener('change', () => {
      const pick = edges.find(e => e.slug === sel.value);
      const sideKey = idx === 0 ? 'P' : 'O';
      sides[sideKey].edge = pick || null;
      effects[idx].textContent = pick ? (pick.effect || '') : '';
      const iconEl = icons[idx];
      if (pick) {
  // Prefer key-based path then fallbacks
  const cands = resolveIconCandidates(pick);
  let i=0; iconEl.src = cands[i] || 'placeholder.png';
  iconEl.onerror = () => { i+=1; if (i<cands.length) { iconEl.src=cands[i]; } else { iconEl.onerror=null; iconEl.src='placeholder.png'; } };
      } else {
        iconEl.src = 'assets/placeholder.png';
      }
    });
  });
}
// populateEdges is invoked from loadData() once DATA_ARR is ready

// Randomize a side's loadout
function randomizeSide(targetSide){
  const side = sides[targetSide];
  // Reset state: clear weapon, items, oils and edge selection
  side.weapon = null;
  side.items = new Array(SLOT_COUNT).fill(null);
  side.oils.clear();
  side.edge = null;
  // Reset DOM: weapon slot text, clear oils active class, reset edge select and effect, and rebuild empty item slots
  const wSlot = targetSide === 'P' ? $('#weaponP') : $('#weaponO');
  wSlot.textContent = 'Drop a Weapon';
  const oilsEl = targetSide === 'P' ? $('#oilsP') : $('#oilsO');
  oilsEl.querySelectorAll('.oil.active').forEach(el => el.classList.remove('active'));
  if (targetSide === 'P') {
    $('#edgeP').value = '';
    $('#edgePEffect').textContent = '';
    $('#edgePIcon').src = 'assets/placeholder.png';
  } else {
    $('#edgeO').value = '';
    $('#edgeOEffect').textContent = '';
    $('#edgeOIcon').src = 'assets/placeholder.png';
  }
  resetSlots(targetSide);
  const gridEl = targetSide === 'P' ? $('#gridP') : $('#gridO');
  const weapons = DATA_ARR.filter(e => e.bucket === 'weapons');
  const itemsList = DATA_ARR.filter(e => e.bucket === 'items');
  const edges = DATA_ARR.filter(e => e.bucket === 'upgrades' && /edge/i.test(e.slug) && !(/_used$/i.test(e.slug) || /_darkened$/i.test(e.slug)));
  
  if (weapons.length) {
    const w = weapons[Math.floor(Math.random()*weapons.length)];
    side.weapon = w;

    // Build mini card icon with fallbacks using key first
    const wIconCandidates = [];
    if (w.key) wIconCandidates.push(`${w.key}/icon.png`);
    if (w.bucket && w.slug) wIconCandidates.push(`${w.bucket}/${w.slug}/icon.png`);
    if (w.slug) {
      wIconCandidates.push(`items/${w.slug}/icon.png`);
      wIconCandidates.push(`weapons/${w.slug}/icon.png`);
    }
    const wFirstIcon = wIconCandidates[0] || 'placeholder.png';
    wSlot.innerHTML = `<div class="miniCard"><img src="${wFirstIcon}" onerror="(function(el){var c=['${wIconCandidates.map(c=>c.replace(/"/g,'&quot;')).join("','")}'];var i=1;el.onerror=function(){if(i<c.length){el.src=c[i++];}else{el.onerror=null;el.src='placeholder.png';}}})(this)" alt="${w.name}"><span class="name">${w.name}</span></div>`;

  }
  
  // Randomly select an edge
  if (edges.length) {
    const randomEdge = edges[Math.floor(Math.random() * edges.length)];
    side.edge = randomEdge;
    
    // Update the edge select dropdown
    const edgeSelect = targetSide === 'P' ? $('#edgeP') : $('#edgeO');
    const edgeEffect = targetSide === 'P' ? $('#edgePEffect') : $('#edgeOEffect');
    const edgeIcon = targetSide === 'P' ? $('#edgePIcon') : $('#edgeOIcon');
    
    edgeSelect.value = randomEdge.slug;
    edgeEffect.textContent = randomEdge.effect || '';
    {
      const cands = resolveIconCandidates(randomEdge);
      let i=0; edgeIcon.src = cands[i] || 'placeholder.png';
      edgeIcon.onerror = () => { i+=1; if (i<cands.length) { edgeIcon.src=cands[i]; } else { edgeIcon.onerror=null; edgeIcon.src='placeholder.png'; } };
    }
  }
  const copy = itemsList.slice();
  const chosen = [];
  for (let i = 0; i < SLOT_COUNT && copy.length; i++) {
    const idxPick = Math.floor(Math.random() * copy.length);
    const pick = copy.splice(idxPick, 1)[0];
    chosen.push(pick);
  }
  const cells = gridEl.querySelectorAll('.slot');
  chosen.forEach((it, idxItem) => {
    side.items[idxItem] = it;
    const cell = cells[idxItem];
  cell.innerHTML = mini(it);
    cell.classList.add('filled');
  });
  updateTotals(targetSide);
  // Select first slot for clarity
  if (chosen.length > 0) selectSlot(targetSide, 0);
}
document.getElementById('randBuildBtn')?.addEventListener('click', () => randomizeSide('P'));
document.getElementById('randEnemyBtn')?.addEventListener('click', () => randomizeSide('O'));

// Collect the current loadout and computed statistics for simulation.  The simulator
// expects an object with a name, a stats object (hp, atk, armor, speed), the
// weapon slug (empty string if none) and a list of item slugs.  This helper reads
// the aggregated numbers from the DOM and extracts the slugs from our side state.
function collectEntityData(sideKey) {
  const prefix = sideKey === 'P' ? 'p' : 'o';
  const hp = parseInt($('#' + prefix + 'H').textContent, 10) || 0;
  const items = (sides[sideKey].items || []).filter(Boolean).map(it => ({ slug: `${it.bucket}/${it.slug}`, tier: it.tier || 'base' }));
  if (sides[sideKey].edge) {
    items.push({ slug: `${sides[sideKey].edge.bucket}/${sides[sideKey].edge.slug}`, tier: 'base' });
  }
  // Inject active set pseudo-items so their hooks participate in the sim
  try {
    const allSlugs = [];
    if (sides[sideKey].weapon) allSlugs.push(`${sides[sideKey].weapon.bucket}/${sides[sideKey].weapon.slug}`);
    for (const it of (sides[sideKey].items||[])) if (it) allSlugs.push(`${it.bucket}/${it.slug}`);
    const setSlugs = (window.HeICSets && window.HeICSets.computeActiveEffectSlugs) ? window.HeICSets.computeActiveEffectSlugs(allSlugs) : [];
    for (const s of (setSlugs||[])) items.push({ slug: s, tier: 'base' });
  } catch(_) {}
  return {
    name: sideKey === 'P' ? 'Player' : 'Opponent',
    hp,
    hpMax: hp,
    atk: parseInt($('#' + prefix + 'A').textContent, 10) || 0,
    armor: parseInt($('#' + prefix + 'R').textContent, 10) || 0,
    speed: parseInt($('#' + prefix + 'S').textContent, 10) || 0,
    weaponSlug: sides[sideKey].weapon ? `${sides[sideKey].weapon.bucket}/${sides[sideKey].weapon.slug}` : null,
    items
  };
}

// -----------------------------------------------------------------------------
// Simulation UI wiring
//
// The simulation panel is a floating box (#simPanel) anchored at the bottom
// right of the viewport. It contains buttons to run a battle, clear the log
// and adjust the number of turns. When the Simulate button is clicked we
// collect the current loadouts, run the simulation via HeICSim and print the
// result and log lines into #simLog. Clear Log simply wipes the log container.

// Simulation UI wiring and enhancements
function updateSimulationPreview() {
  const createSideHtml = (sideKey) => {
    const side = sides[sideKey];
    const prefix = sideKey === 'P' ? 'p' : 'o';
    const hp = parseInt(document.getElementById(`${prefix}H`).textContent) || 10;
    const atk = parseInt(document.getElementById(`${prefix}A`).textContent) || 0;
    const arm = parseInt(document.getElementById(`${prefix}R`).textContent) || 0;
    const spd = parseInt(document.getElementById(`${prefix}S`).textContent) || 0;

    const color = sideKey === 'P' ? '#0f3' : '#f33';
    const bgColor = sideKey === 'P' ? 'rgba(0,255,51,0.1)' : 'rgba(255,51,51,0.1)';

    let weaponHtml = `
      <div class="analysisItem weapon" style="background:${bgColor}; border-color:${color}; margin-bottom:0;">
        <div class="analysisItemHeader">
          <img src="assets/placeholder.png" alt="No Weapon">
          <div class="analysisItemName">No Weapon</div>
        </div>
        <div class="analysisItemStats">
          <div class="pill"><img src="assets/health.png" alt="health"><span>${hp}</span></div>
          <div class="pill"><img src="assets/attack.png" alt="attack"><span>${atk}</span></div>
          <div class="pill"><img src="assets/armor.png" alt="armor"><span>${arm}</span></div>
          <div class="pill"><img src="assets/speed.png" alt="speed"><span>${spd}</span></div>
        </div>
      </div>
    `;
    if (side.weapon) {
      weaponHtml = renderAnalysisItem(side.weapon, 'weapon', {bgColor, color});
    }

    let edgeHtml = '';
    if (side.edge) {
      edgeHtml = renderAnalysisItem(side.edge, 'edge', {bgColor, color});
    }

    const items = side.items.filter(Boolean);
    const itemsHtml = items.length > 0 
      ? items.map(item => renderAnalysisItem(item, 'item', {bgColor, color})).join('')
      : '<div class="emptySlot">No items equipped</div>';

    return `
      ${weaponHtml}
      ${edgeHtml}
      <div style="border-top: 2px solid ${color}; margin: 8px 0;"></div>
      ${itemsHtml}
    `;
  };

  const playerPreview = document.getElementById('simPlayerPreview');
  const opponentPreview = document.getElementById('simOpponentPreview');

  if (playerPreview) {
    playerPreview.innerHTML = createSideHtml('P');
  }
  if (opponentPreview) {
    opponentPreview.innerHTML = createSideHtml('O');
  }
}

// Function to update the three-pane simulation interface
function updateSimulationPreview() {
  updateFighterCards();
  updateLoadoutTrays();
  updatePinnedMetrics();
}

// Update fighter stat cards
function updateFighterCards() {
  // Player card
  const playerHP = document.getElementById('playerHP');
  const playerMaxHP = document.getElementById('playerMaxHP');
  const playerArmor = document.getElementById('playerArmor');
  const playerAttack = document.getElementById('playerAttack');
  const playerSpeed = document.getElementById('playerSpeed');
  const playerStatusEffects = document.getElementById('playerStatusEffects');
  
  if (playerHP) {
    const side = sides.P;
    let hp = side.hpBase, atk = side.atkBase, arm = side.armBase, spd = side.spdBase;
    
    // Calculate stats
    const addStats = obj => {
      if (!obj) return;
      const s = obj.stats || {};
      hp += (s.health || 0);
      atk += (s.attack || 0);
      arm += (s.armor || 0);
      spd += (s.speed || 0);
    };
    
    addStats(side.weapon);
    side.items.forEach(addStats);
    if (side.weapon) {
      if (side.oils.has('attack')) atk += 1;
      if (side.oils.has('armor')) arm += 1;
      if (side.oils.has('speed')) spd += 1;
    }
    
    playerHP.textContent = hp;
    playerMaxHP.textContent = hp;
    playerArmor.textContent = arm;
    playerAttack.textContent = atk;
    playerSpeed.textContent = spd;
    
    // Update status effects with enhanced chips
    if (playerStatusEffects) {
      // This is placeholder - real status effects would come from battle simulation
      playerStatusEffects.innerHTML = '';
      
      // Example enhanced status chips (would be populated with actual data)
      const exampleStatuses = [
        { name: 'Poison', value: 5, trend: 2, icon: '‚ò†Ô∏è' },
        { name: 'Regen', value: 3, trend: -1, icon: 'üíö' }
      ];
      
      if (exampleStatuses.length === 0) {
        playerStatusEffects.innerHTML = '<div style="color: #666; font-size: 11px; font-style: italic;">No status effects</div>';
      } else {
        exampleStatuses.forEach(status => {
          const chip = createEnhancedStatusChip(status.name, status.value, status.trend, status.icon);
          playerStatusEffects.appendChild(chip);
        });
      }
    }
  }
  
  // Opponent card
  const opponentHP = document.getElementById('opponentHP');
  const opponentMaxHP = document.getElementById('opponentMaxHP');
  const opponentArmor = document.getElementById('opponentArmor');
  const opponentAttack = document.getElementById('opponentAttack');
  const opponentSpeed = document.getElementById('opponentSpeed');
  const opponentStatusEffects = document.getElementById('opponentStatusEffects');
  
  if (opponentHP) {
    const side = sides.O;
    let hp = side.hpBase, atk = side.atkBase, arm = side.armBase, spd = side.spdBase;
    
    // Calculate stats
    const addStats = obj => {
      if (!obj) return;
      const s = obj.stats || {};
      hp += (s.health || 0);
      atk += (s.attack || 0);
      arm += (s.armor || 0);
      spd += (s.speed || 0);
    };
    
    addStats(side.weapon);
    side.items.forEach(addStats);
    if (side.weapon) {
      if (side.oils.has('attack')) atk += 1;
      if (side.oils.has('armor')) arm += 1;
      if (side.oils.has('speed')) spd += 1;
    }
    
    opponentHP.textContent = hp;
    opponentMaxHP.textContent = hp;
    opponentArmor.textContent = arm;
    opponentAttack.textContent = atk;
    opponentSpeed.textContent = spd;
    
    // Update status effects with enhanced chips
    if (opponentStatusEffects) {
      opponentStatusEffects.innerHTML = '';
      
      // Example enhanced status chips (would be populated with actual data)
      const exampleStatuses = [
        { name: 'Thorns', value: 2, trend: 0, icon: 'üåø' }
      ];
      
      if (exampleStatuses.length === 0) {
        opponentStatusEffects.innerHTML = '<div style="color: #666; font-size: 11px; font-style: italic;">No status effects</div>';
      } else {
        exampleStatuses.forEach(status => {
          const chip = createEnhancedStatusChip(status.name, status.value, status.trend, status.icon);
          opponentStatusEffects.appendChild(chip);
        });
      }
    }
  }
}

// Enhanced micro-pattern helper functions
function createEnhancedStatusChip(statusName, value, trend, icon) {
  const chip = document.createElement('div');
  chip.className = `status-chip ${statusName.toLowerCase()}`;
  
  let content = '';
  if (icon) {
    content += `<span class="status-chip-icon">${icon}</span>`;
  }
  content += `<span class="status-chip-value">${statusName} ${value}</span>`;
  
  if (trend !== undefined && trend !== 0) {
    const trendClass = trend > 0 ? 'positive' : 'negative';
    const trendSymbol = trend > 0 ? '+' : '';
    content += `<span class="status-chip-trend ${trendClass}">${trendSymbol}${trend}</span>`;
  }
  
  chip.innerHTML = content;
  return chip;
}

function createEnhancedPhaseHeader(phaseName, triggerCount, metadata) {
  const header = document.createElement('div');
  header.className = 'log-phase-header';
  
  const title = document.createElement('div');
  title.className = 'phase-title';
  title.textContent = phaseName;
  
  const meta = document.createElement('div');
  meta.className = 'phase-meta';
  
  if (triggerCount > 0) {
    const triggers = document.createElement('span');
    triggers.className = 'trigger-count';
    triggers.textContent = `${triggerCount} triggers`;
    meta.appendChild(triggers);
  }
  
  if (metadata) {
    const metaText = document.createElement('span');
    metaText.textContent = metadata;
    meta.appendChild(metaText);
  }
  
  header.appendChild(title);
  header.appendChild(meta);
  return header;
}

function createEffectRow(source, target, description) {
  const row = document.createElement('div');
  row.className = 'effect-row';
  
  row.innerHTML = `
    <span class="effect-source">${source}</span>
    <span class="effect-arrow">‚Üí</span>
    <span class="effect-target">${target}:</span>
    <span class="effect-description">${description}</span>
  `;
  
  return row;
}

function createSynergyTag(type, count) {
  const tag = document.createElement('span');
  tag.className = `synergy-tag ${type.toLowerCase()}`;
  tag.textContent = `${type} √ó${count}`;
  return tag;
}

function createSummaryStrip(stats) {
  const strip = document.createElement('div');
  strip.className = 'summary-strip';
  
  Object.entries(stats).forEach(([key, value]) => {
    const stat = document.createElement('div');
    stat.className = `summary-stat ${key.toLowerCase()}`;
    stat.innerHTML = `
      <span>${key.charAt(0).toUpperCase() + key.slice(1)}</span>
      <span class="summary-stat-value">${value}</span>
    `;
    strip.appendChild(stat);
  });
  
  return strip;
}

// Update loadout trays
function updateLoadoutTrays() {
  updateLoadoutTray('Player', sides.P, 'playerLoadoutDisplay');
  updateLoadoutTray('Opponent', sides.O, 'opponentLoadoutDisplay');
}

function updateLoadoutTray(sideName, side, containerId) {
  const container = document.getElementById(containerId);
  if (!container) return;
  
  const items = [];
  
  // Add weapon
  if (side.weapon) {
    items.push({
      type: 'weapon',
      name: side.weapon.name,
      slug: side.weapon.key || side.weapon.slug,
      tier: 'base'
    });
  }
  
  // Add items
  side.items.forEach((item, idx) => {
    if (item) {
      items.push({
        type: 'item',
        name: item.name,
        slug: item.key || item.slug,
        tier: item.tier || 'base'
      });
    }
  });
  
  // Add edge
  if (side.edge) {
    const edgeData = RAW_DATA[side.edge];
    if (edgeData) {
      items.push({
        type: 'edge',
        name: edgeData.name,
        slug: edgeData.key || edgeData.slug,
        tier: 'base'
      });
    }
  }
  
  if (items.length === 0) {
    container.innerHTML = '<div style="color: #666; font-size: 11px; font-style: italic; text-align: center; padding: 12px;">No items equipped</div>';
    return;
  }
  
  container.innerHTML = items.map(item => {
    const iconPath = `${item.slug}/icon.png`;
    const tierClass = item.tier !== 'base' ? ` tier-${item.tier}` : '';
    const typeClass = item.type === 'weapon' ? ' weapon' : '';
    
    return `
      <div class="loadout-item${tierClass}${typeClass}" title="${item.name}${item.tier !== 'base' ? ` (${item.tier})` : ''}">
        <img src="${iconPath}" alt="${item.name}" onerror="this.src='assets/placeholder.png'">
        <span>${item.name}</span>
        ${item.tier !== 'base' ? `<span style="font-size: 9px; color: #fa0; margin-left: 4px;">${item.tier}</span>` : ''}
      </div>
    `;
  }).join('');
}

// Update pinned metrics (placeholder for now)
function updatePinnedMetrics(battleSummary) {
  // Get or create the pinned metrics container
  const pinnedMetrics = document.getElementById('pinnedMetrics');
  if (!pinnedMetrics) return;
  
  if (battleSummary && battleSummary.left && battleSummary.right) {
    // Clear existing content
    pinnedMetrics.innerHTML = '';
    
    // Create summary strip with actual battle data
    const summaryStats = {
      'Dmg Dealt': battleSummary.left.damageDealt || 0,
      'Dmg Taken': battleSummary.left.damageTaken || 0,
      'Healing': battleSummary.left.healingReceived || 0,
      'Effects': battleSummary.left.effectsTriggered || 0
    };
    
    const summaryStrip = createSummaryStrip(summaryStats);
    pinnedMetrics.appendChild(summaryStrip);
    
    // Add synergy tags if available
    const synergyContainer = document.createElement('div');
    synergyContainer.style.marginTop = '8px';
    
    // Example synergy detection (would need actual implementation)
    const playerItems = sides.P.items.concat([sides.P.weapon]).filter(Boolean);
    const symphonyCount = playerItems.filter(item => item.tags && item.tags.includes('Symphony')).length;
    const bombCount = playerItems.filter(item => item.tags && item.tags.includes('Bomb')).length;
    const fruitCount = playerItems.filter(item => item.tags && item.tags.includes('Fruit')).length;
    
    if (symphonyCount >= 2) {
      synergyContainer.appendChild(createSynergyTag('Symphony', symphonyCount));
    }
    if (bombCount >= 2) {
      synergyContainer.appendChild(createSynergyTag('Bomb', bombCount));
    }
    if (fruitCount >= 2) {
      synergyContainer.appendChild(createSynergyTag('Fruit', fruitCount));
    }
    
    if (synergyContainer.children.length > 0) {
      pinnedMetrics.appendChild(synergyContainer);
    }
  } else {
    // Default placeholder content
    pinnedMetrics.innerHTML = `
      <div class="summary-strip">
        <div class="summary-stat">
          <span>Dmg Dealt</span>
          <span class="summary-stat-value">0</span>
        </div>
        <div class="summary-stat">
          <span>Dmg Taken</span>
          <span class="summary-stat-value">0</span>
        </div>
        <div class="summary-stat">
          <span>Healing</span>
          <span class="summary-stat-value">0</span>
        </div>
        <div class="summary-stat">
          <span>Effects</span>
          <span class="summary-stat-value">0</span>
        </div>
      </div>
    `;
  }
}

// Enhanced log rendering for new three-pane layout
function renderCardifiedLog(logEntries) {
  const simLog = document.getElementById('simLog');
  if (!simLog || !logEntries) return;
  
  // Clear existing content
  simLog.innerHTML = '';
  
  // Group log entries by phase
  const phases = [];
  let currentPhase = null;
  
  logEntries.forEach((entry, index) => {
    const entryStr = String(entry);
    
    // Detect phase headers
    if (entryStr.match(/^\d+\.\s*--\s*Turn\s+\d+\s*--/) || entryStr.includes('Battle Start') || entryStr.includes('BATTLE')) {
      if (currentPhase) {
        phases.push(currentPhase);
      }
      
      currentPhase = {
        header: entryStr,
        type: entryStr.includes('Turn') ? 'turn-start' : 'battle-start',
        entries: [],
        triggers: 0,
        changes: 0
      };
    } else if (currentPhase) {
      currentPhase.entries.push(entry);
      
      // Count triggers and changes (simple heuristic)
      if (entryStr.includes('::icon:')) currentPhase.triggers++;
      if (entryStr.includes('gains') || entryStr.includes('loses') || entryStr.includes('deals')) currentPhase.changes++;
    }
  });
  
  // Add final phase
  if (currentPhase) {
    phases.push(currentPhase);
  }
  
  // Render phases as cards
  phases.forEach(phase => {
    const phaseCard = document.createElement('div');
    phaseCard.className = 'log-phase-card';
    
    // Use enhanced phase header with micro-patterns
    const phaseName = phase.header.replace(/^\d+\.\s*--\s*/, '').replace(/\s*--.*$/, '');
    let metadata = '';
    if (phase.type === 'turn-start') {
      metadata = `On Hit (${phase.triggers} triggers)`;
    } else {
      metadata = phase.triggers > 0 ? `${phase.triggers} effects` : '';
    }
    
    const header = createEnhancedPhaseHeader(phaseName, phase.triggers, metadata);
    
    const content = document.createElement('div');
    content.className = 'log-phase-content';
    
    // Render entries with enhanced effect rows
    phase.entries.forEach(entry => {
      const entryDiv = document.createElement('div');
      entryDiv.style.marginBottom = '4px';
      entryDiv.style.fontSize = '12px';
      entryDiv.style.color = '#ccc';
      
      const entryStr = String(entry);
      const iconMatch = entryStr.match(/^::icon:([^:]+)::\s*(.*)$/);
      
      if (iconMatch) {
        const slug = iconMatch[1];
        const text = iconMatch[2];
        
        // Try to create an enhanced effect row
        const effectMatch = text.match(/(.+?)\s+(gains?|loses?|deals?)\s+(.+)/);
        if (effectMatch) {
          const itemName = slug.split('/').pop().replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          const target = effectMatch[1];
          const action = effectMatch[2];
          const effect = effectMatch[3];
          
          const effectRow = createEffectRow(itemName, target, `${action} ${effect}`);
          entryDiv.appendChild(effectRow);
        } else {
          entryDiv.innerHTML = `
            <img src="${slug}/icon.png" style="width: 16px; height: 16px; image-rendering: pixelated; margin-right: 6px; vertical-align: middle;" onerror="this.style.display='none'">
            <span>${enhancePlayerNames(text)}</span>
          `;
        }
      } else {
        entryDiv.innerHTML = enhancePlayerNames(entryStr);
      }
      
      content.appendChild(entryDiv);
    });
    
    // Toggle functionality
    let expanded = false;
    header.addEventListener('click', () => {
      expanded = !expanded;
      if (expanded) {
        content.style.display = 'block';
        content.classList.add('expanded');
        header.querySelector('div:last-child').textContent = '‚ñ≤';
        phaseCard.classList.add('expanded');
      } else {
        content.style.display = 'none';
        content.classList.remove('expanded');
        header.querySelector('div:last-child').textContent = '‚ñº';
        phaseCard.classList.remove('expanded');
      }
    });
    
    phaseCard.appendChild(header);
    phaseCard.appendChild(content);
    simLog.appendChild(phaseCard);
  });
  
  simLog.scrollTop = simLog.scrollHeight;
}

// Function to enhance player names in battle log text
function enhancePlayerNames(text) {
  if (!text) return text;
  
  // Enhanced Player name styling - make it bigger and more prominent
  text = text.replace(/\bPlayer\b/g, '<span class="player-name player-1">Player</span>');
  
  // Enhanced Opponent name styling - make it bigger and more prominent  
  text = text.replace(/\bOpponent\b/g, '<span class="player-name player-2">Opponent</span>');
  
  // Also handle Fighter names if they appear
  text = text.replace(/\bFighter\b(?=\s+(hits|deals|gains|loses))/g, '<span class="player-name player-1">Fighter</span>');
  
  return text;
}

function uiLogClear() {
  const log = document.getElementById('simLog');
  const battleStatus = document.getElementById('battleStatus');
  const battleSummary = document.getElementById('battleSummary');
  
  if (log) {
    log.innerHTML = `
      <div style="text-align:center; color:#666; font-style:italic; font-size:18px; padding:60px 20px;">
        <img src="assets/attack.png" style="width:16px; height:16px; vertical-align:middle; image-rendering:pixelated;"> Ready to witness epic battles!<br><br>
        Configure your loadouts and hit <strong style="color:#0f3;">"START BATTLE"</strong> to begin the simulation.
      </div>
    `;
  }
  
  if (battleStatus) battleStatus.textContent = 'Ready for Battle';
  if (battleSummary) battleSummary.style.display = 'none';
}

function uiLog(lines) {
  const log = document.getElementById('simLog');
  if (!log) return;
  
  // Clear initial message if it's the first log entry
  if (log.innerHTML.includes('Ready to witness epic battles')) {
    log.innerHTML = '';
  }
  
  const renderLine = (line) => {
    if (line == null) return;
    const div = document.createElement('div');
    div.className = 'logLine battle-log-line';
    
    const lineStr = String(line);
    
    // Check for section dividers first
    if (lineStr.includes('‚îÅ‚îÅ‚îÅ') || lineStr.includes('BATTLE BEGINS') || lineStr.includes('BATTLE ENDED')) {
      div.className = 'battle-divider major';
      div.innerHTML = lineStr;
      log.appendChild(div);
      return;
    }
    
    // Check for turn headers
    if (lineStr.match(/^\d+\.\s*--\s*Turn\s+\d+\s*--/)) {
      div.className = 'battle-divider';
      div.innerHTML = lineStr;
      log.appendChild(div);
      return;
    }
    
    // Determine line type for styling
    if (lineStr.includes('Player') || lineStr.includes('Fighter')) {
      div.classList.add('player');
    } else if (lineStr.includes('Opponent') || lineStr.includes('Enemy')) {
      div.classList.add('opponent');
    } else if (lineStr.includes('Turn') || lineStr.includes('Result') || lineStr.includes('Summary')) {
      div.classList.add('system');
    }
    
    const m = lineStr.match(/^::icon:([^:]+)::\s*(.*)$/);
    if (m) {
      const slug = m[1];
      const text = m[2];
      const img = document.createElement('img');
      img.src = slug + '/icon.png';
      img.alt = '';
      img.style.width = '24px';
      img.style.height = '24px';
      img.style.imageRendering = 'pixelated';
      img.style.marginRight = '8px';
      img.style.verticalAlign = 'middle';
      img.style.border = '1px solid rgba(0,255,51,0.3)';
      img.style.borderRadius = '4px';
      img.style.backgroundColor = 'rgba(0,0,0,0.2)';
      img.onerror = () => {
        img.style.display = 'none';
      };
      div.appendChild(img);
      
      // Add item name if we can find it
      const itemData = (window.HEIC_DETAILS || {})[slug];
      if (itemData && itemData.name) {
        const nameSpan = document.createElement('span');
        nameSpan.textContent = `[${itemData.name}] `;
        nameSpan.style.color = '#fa0';
        nameSpan.style.fontWeight = 'bold';
        div.appendChild(nameSpan);
      }
      
      const textDiv = document.createElement('span');
      textDiv.innerHTML = enhancePlayerNames(text);
      div.appendChild(textDiv);
    } else {
      // Use innerHTML instead of textContent to render HTML img tags
      div.innerHTML = enhancePlayerNames(lineStr);
    }
    
    log.appendChild(div);
  };
  
  if (Array.isArray(lines)) { 
    for (const l of lines) renderLine(l); 
  } else { 
    renderLine(lines); 
  }
  
  log.scrollTop = log.scrollHeight;
}

function displayBattleResult(result, rounds, summary) {
  const battleStatus = document.getElementById('battleStatus');
  const battleSummary = document.getElementById('battleSummary');
  const playerSummaryContent = document.getElementById('playerSummaryContent');
  const opponentSummaryContent = document.getElementById('opponentSummaryContent');
  
  // Update battle status with result
  if (battleStatus) {
    let statusText = '';
    let statusClass = '';
    
    switch(result) {
      case 'Victory':
        statusText = '<img src="assets/health.png" style="width:16px; height:16px; vertical-align:middle; image-rendering:pixelated;"> VICTORY!';
        statusClass = 'result-victory';
        break;
      case 'Defeat':
        statusText = 'üíÄ DEFEAT!';
        statusClass = 'result-defeat';
        break;
      case 'Draw':
        statusText = 'ü§ù DRAW!';
        statusClass = 'result-draw';
        break;
      default:
        statusText = result;
        break;
    }
    
    battleStatus.innerHTML = `<span class="${statusClass}">${statusText} (${rounds} rounds)</span>`;
  }
  
  // Show summary if available
  if (summary && battleSummary) {
    battleSummary.style.display = 'block';
    
    const formatSummary = (s) => {
      let setsHtml = '';
      if (s.sets && s.sets.length > 0) {
        setsHtml = `
          <div style="margin-top:16px; padding-top:12px; border-top:2px solid rgba(255,255,255,0.2);">
            <div style="font-weight:700; font-size:18px; margin-bottom:10px; color:#f93;"><img src="assets/health.png" style="width:16px; height:16px; vertical-align:middle; image-rendering:pixelated;"> Active Sets</div>
            <div style="font-size:16px; line-height:1.5;">
              ${s.sets.map(set => `<div style="margin-bottom:8px; padding:8px; background:rgba(255,153,51,0.1); border-radius:6px; border-left:4px solid #f93;"><strong>${set.name}:</strong> ${set.desc}</div>`).join('')}
            </div>
          </div>
        `;
      }
      
      return `
        <div style="margin-bottom:8px;"><strong>HP Remaining:</strong> ${s.hpRemaining}</div>
        <div style="margin-bottom:8px;"><strong>Damage Dealt:</strong> ${s.hpDamageDealt}</div>
        <div style="margin-bottom:8px;"><strong>Armor Destroyed:</strong> ${s.armorDestroyedDealt}</div>
        <div style="margin-bottom:8px;"><strong>Strikes:</strong> ${s.strikesLanded}/${s.strikesAttempted}</div>
        <div style="margin-bottom:8px;"><strong>Bomb Damage:</strong> ${s.bombHpDealt || 0}</div>
        ${setsHtml}
      `;
    };
    
    if (playerSummaryContent) {
      playerSummaryContent.innerHTML = formatSummary(summary.left);
    }
    
    if (opponentSummaryContent) {
      opponentSummaryContent.innerHTML = formatSummary(summary.right);
    }
  }
}

const simBtn = document.getElementById('btnSimulate');
const showSimBtn = document.getElementById('showSimBtn');

if (simBtn) {
  simBtn.addEventListener('click', () => {
    // Automatically switch to the simulation tab
    showTab('simulation');

    updateTotals('P');
    updateTotals('O');
    const left = collectEntityData('P');
    const right = collectEntityData('O');
    const maxTurns = 200; // Fixed to 200 turns
    
    // Update battle status
    const battleStatus = document.getElementById('battleStatus');
    if (battleStatus) battleStatus.innerHTML = '<img src="assets/attack.png" style="width:16px; height:16px; vertical-align:middle; image-rendering:pixelated;"> Battle in Progress...';
    
    // Hide replay controls during simulation
    const timelineControls = document.getElementById('timelineControls');
    if (timelineControls) timelineControls.style.display = 'none';
    
    // Update fighter cards with initial states
    updateFighterCards();
    
    // Clear log
    uiLogClear();
    
    if (typeof HeICSim === 'undefined' || !HeICSim.simulate) {
      uiLog('‚ùå Simulation engine failed to load.');
      if (battleStatus) battleStatus.textContent = 'Error: Engine Failed';
      return;
    }
    
    try {
      const res = HeICSim.simulate(left, right, { maxTurns: maxTurns, includeSummary: true });
      
      // Use new cardified log rendering
      if (res.log) {
        renderCardifiedLog(res.log);
      }
      
      // Show timeline controls after simulation
      if (timelineControls) {
        timelineControls.style.display = 'block';
        BattleReplayController.loadBattle(res);
      }
      
      // Update battle status
      if (battleStatus) {
        const resultText = res.result === 'Victory' ? 'Player Victory!' : 
                          res.result === 'Defeat' ? 'Player Defeat!' : 'Draw!';
        const resultColor = res.result === 'Victory' ? '#0f3' : 
                           res.result === 'Defeat' ? '#f33' : '#fa0';
        battleStatus.innerHTML = `<span style="color:${resultColor}">${resultText} (${res.rounds} rounds)</span>`;
      }
      
      // Update fighter results
      const playerResult = document.getElementById('playerResult');
      const opponentResult = document.getElementById('opponentResult');
      if (playerResult && opponentResult) {
        if (res.result === 'Victory') {
          playerResult.innerHTML = '<span style="color: #0f3;">WINNER</span>';
          playerResult.style.display = 'block';
          opponentResult.innerHTML = '<span style="color: #666;">LOSER</span>';
          opponentResult.style.display = 'block';
        } else if (res.result === 'Defeat') {
          playerResult.innerHTML = '<span style="color: #666;">LOSER</span>';
          playerResult.style.display = 'block';
          opponentResult.innerHTML = '<span style="color: #f33;">WINNER</span>';
          opponentResult.style.display = 'block';
        } else {
          playerResult.innerHTML = '<span style="color: #fa0;">DRAW</span>';
          playerResult.style.display = 'block';
          opponentResult.innerHTML = '<span style="color: #fa0;">DRAW</span>';
          opponentResult.style.display = 'block';
        }
      }
      
      // Update final HP/stats if available in summary
      if (res.summary) {
        updateFinalStats(res.summary);
        updatePinnedMetrics(res.summary);
      }
      
      // Re-apply noise filter if active
      const noiseFilterToggle = document.getElementById('noiseFilterToggle');
      if (noiseFilterToggle && noiseFilterToggle.checked) {
        filterBattleLog(true);
      }
      
      // Run battle analysis with the simulation results
      runBattleAnalysis(res);
      
    } catch (ex) {
      console.error(ex);
      uiLog('‚ùå Error running simulation: ' + ex.message);
      if (battleStatus) battleStatus.textContent = 'Error: Simulation Failed';
    }
  });
}

// Update final stats in fighter cards after simulation
function updateFinalStats(summary) {
  if (!summary || !summary.left || !summary.right) return;
  
  // Update player final stats
  const playerHP = document.getElementById('playerHP');
  const playerArmor = document.getElementById('playerArmor');
  if (playerHP) playerHP.textContent = summary.left.hpRemaining || 0;
  if (playerArmor) playerArmor.textContent = summary.left.armorRemaining || 0;
  
  // Update opponent final stats
  const opponentHP = document.getElementById('opponentHP');
  const opponentArmor = document.getElementById('opponentArmor');
  if (opponentHP) opponentHP.textContent = summary.right.hpRemaining || 0;
  if (opponentArmor) opponentArmor.textContent = summary.right.armorRemaining || 0;
}

// Noise filter functionality
function setupNoiseFilter() {
  const noiseFilterToggle = document.getElementById('noiseFilterToggle');
  if (noiseFilterToggle) {
    noiseFilterToggle.addEventListener('change', () => {
      filterBattleLog(noiseFilterToggle.checked);
    });
  }
}

function filterBattleLog(hideNoise) {
  const logCards = document.querySelectorAll('.log-phase-card');
  
  if (!hideNoise) {
    // Show all cards
    logCards.forEach(card => {
      card.style.display = 'block';
    });
    return;
  }
  
  // Hide noise entries
  logCards.forEach(card => {
    const content = card.querySelector('.log-phase-content');
    if (!content) return;
    
    const entries = content.children;
    let hasSignificantContent = false;
    
    for (let i = 0; i < entries.length; i++) {
      const entry = entries[i];
      const text = entry.textContent || '';
      
      // Check if this is a "no-op" or redundant event
      const isNoise = text.includes('Tried to') ||
                      text.includes('had none to remove') ||
                      text.includes('already at') ||
                      text.includes('no effect') ||
                      text.includes('0 damage') ||
                      text.includes('misses') ||
                      (text.includes('gains 0') && !text.includes('loses'));
      
      if (!isNoise) {
        hasSignificantContent = true;
        break;
      }
    }
    
    card.style.display = hasSignificantContent ? 'block' : 'none';
  });
}

const clearBtn = document.getElementById('btnClearLog');
if (clearBtn) {
  clearBtn.addEventListener('click', () => {
    uiLogClear();
    
    // Hide timeline controls when clearing
    const timelineControls = document.getElementById('timelineControls');
    if (timelineControls) timelineControls.style.display = 'none';
    
    // Reset fighter results
    const playerResult = document.getElementById('playerResult');
    const opponentResult = document.getElementById('opponentResult');
    if (playerResult) playerResult.style.display = 'none';
    if (opponentResult) opponentResult.style.display = 'none';
    
    // Reset fighter stats to initial values
    updateFighterCards();
    
    // Reset battle analysis
    showEmptyAnalysis();
  });
}

// Initialize noise filter
setupNoiseFilter();

// Timeline controls functionality
function setupTimelineControls() {
  const timelineSlider = document.getElementById('timelineSlider');
  const stepBackBtn = document.getElementById('stepBackBtn');
  const stepForwardBtn = document.getElementById('stepForwardBtn');
  const replayBtn = document.getElementById('replayBtn');
  
  // For now, these are placeholders - full timeline functionality would require
  // tracking simulation state at each step
  if (stepBackBtn) {
    stepBackBtn.addEventListener('click', () => {
      console.log('Step back clicked - feature placeholder');
    });
  }
  
  if (stepForwardBtn) {
    stepForwardBtn.addEventListener('click', () => {
      console.log('Step forward clicked - feature placeholder');
    });
  }
  
  if (replayBtn) {
    replayBtn.addEventListener('click', () => {
      console.log('Replay clicked - feature placeholder');
    });
  }
}

// Setup grouping toggle
function setupLogGrouping() {
  const groupToggle = document.getElementById('groupTriggersToggle');
  if (groupToggle) {
    groupToggle.addEventListener('change', () => {
      groupLogEntries(groupToggle.checked);
    });
  }
}

function groupLogEntries(shouldGroup) {
  // This is a placeholder - full grouping would require analysis of log entries
  // and restructuring them by trigger type or timing
  console.log('Log grouping toggled:', shouldGroup);
}

// Initialize all controls
setupTimelineControls();
setupLogGrouping();

// ============================================================================
// Battle Analysis System
// ============================================================================

let currentBattleAnalysis = null;
let currentSimulationLog = null;

// Initialize Battle Analysis System
function initializeBattleAnalysis() {
  // Setup panel toggle functionality
  document.querySelectorAll('.analysis-panel-header').forEach(header => {
    header.addEventListener('click', () => {
      const panel = header.parentElement;
      panel.classList.toggle('collapsed');
      const toggle = header.querySelector('.analysis-toggle');
      toggle.textContent = panel.classList.contains('collapsed') ? '+' : '‚àí';
    });
  });
  
  // Setup Why Inspector
  const closeBtn = document.getElementById('closeWhyInspector');
  if (closeBtn) {
    closeBtn.addEventListener('click', () => {
      const inspector = document.getElementById('whyInspector');
      inspector.classList.remove('open');
    });
  }
}

// Main function to run battle analysis
function runBattleAnalysis(battleResult) {
  if (!battleResult || !battleResult.log || !battleResult.summary) {
    showEmptyAnalysis();
    return;
  }
  
  currentBattleAnalysis = analyzeBattle(battleResult);
  currentSimulationLog = battleResult.log;
  
  renderBattleAnalysis(currentBattleAnalysis);
}

// Analyze battle results to extract insights
function analyzeBattle(battleResult) {
  const analysis = {
    outcome: analyzeOutcome(battleResult),
    damageSources: analyzeDamageSources(battleResult),
    statusImpact: analyzeStatusImpact(battleResult),
    triggerHeatmap: analyzeTriggerHeatmap(battleResult),
    armorEconomy: analyzeArmorEconomy(battleResult),
    synergies: analyzeSynergies(battleResult),
    bottlenecks: analyzeBottlenecks(battleResult),
    recommendations: generateRecommendations(battleResult)
  };
  
  return analysis;
}

// Analyze battle outcome and key metrics
function analyzeOutcome(battleResult) {
  const summary = battleResult.summary;
  const left = summary.left || {};
  const right = summary.right || {};
  
  return {
    ttk: battleResult.rounds || 0,
    survived: battleResult.result !== 'Defeat',
    damageDealt: left.damageDealt || 0,
    damageTaken: left.damageTaken || 0,
    strikeUptime: calculateStrikeUptime(battleResult),
    netTempo: calculateNetTempo(battleResult)
  };
}

// Analyze damage sources and their contributions
function analyzeDamageSources(battleResult) {
  const log = battleResult.log || [];
  const sources = {};
  let totalDamage = 0;
  
  // Parse log for damage sources (simplified implementation)
  log.forEach(entry => {
    const entryStr = String(entry);
    
    // Match damage entries like "::icon:items/cherry_bomb:: Fighter deals 2 damage"
    const damageMatch = entryStr.match(/::icon:([^:]+)::\s*\w+\s+deals\s+(\d+)\s+damage/);
    if (damageMatch) {
      const source = damageMatch[1].split('/').pop().replace(/_/g, ' ');
      const damage = parseInt(damageMatch[2]);
      
      sources[source] = (sources[source] || 0) + damage;
      totalDamage += damage;
    }
    
    // Match strike damage
    const strikeMatch = entryStr.match(/‚öîÔ∏è.*hits.*for\s+(\d+)/);
    if (strikeMatch) {
      const damage = parseInt(strikeMatch[1]);
      sources['Weapon Strike'] = (sources['Weapon Strike'] || 0) + damage;
      totalDamage += damage;
    }
  });
  
  // Convert to array with percentages
  const sourceArray = Object.entries(sources).map(([name, damage]) => ({
    name: name.replace(/\b\w/g, l => l.toUpperCase()),
    damage,
    percentage: totalDamage > 0 ? Math.round((damage / totalDamage) * 100) : 0
  })).sort((a, b) => b.damage - a.damage);
  
  return { sources: sourceArray, totalDamage };
}

// Analyze status effect impact
function analyzeStatusImpact(battleResult) {
  const log = battleResult.log || [];
  const statusEffects = {};
  
  log.forEach(entry => {
    const entryStr = String(entry);
    
    // Match status applications
    const statusMatch = entryStr.match(/(gains?|applies?)\s+(\d+)\s+(\w+)/i);
    if (statusMatch) {
      const amount = parseInt(statusMatch[2]);
      const status = statusMatch[3].toLowerCase();
      
      if (!statusEffects[status]) {
        statusEffects[status] = {
          applications: 0,
          totalValue: 0,
          avgValue: 0,
          damage: 0
        };
      }
      
      statusEffects[status].applications++;
      statusEffects[status].totalValue += amount;
    }
    
    // Match status damage
    const statusDamageMatch = entryStr.match(/(\w+)\s+deals\s+(\d+)\s+damage/);
    if (statusDamageMatch) {
      const status = statusDamageMatch[1].toLowerCase();
      const damage = parseInt(statusDamageMatch[2]);
      
      if (statusEffects[status]) {
        statusEffects[status].damage += damage;
      }
    }
  });
  
  // Calculate averages
  Object.values(statusEffects).forEach(effect => {
    effect.avgValue = effect.applications > 0 ? 
      Math.round(effect.totalValue / effect.applications) : 0;
  });
  
  return statusEffects;
}

// Create trigger heatmap
function analyzeTriggerHeatmap(battleResult) {
  // This would require detailed simulation data tracking
  // For now, return mock data structure
  return {
    phases: ['Battle Start', 'Turn Start', 'On Hit', 'On Wounded', 'On Exposed'],
    items: getCurrentPlayerItems(),
    matrix: {} // Would be filled with actual trigger counts
  };
}

// Analyze armor economy
function analyzeArmorEconomy(battleResult) {
  const log = battleResult.log || [];
  let armorGained = 0;
  let armorLost = 0;
  let preventedDamage = 0;
  
  log.forEach(entry => {
    const entryStr = String(entry);
    
    const armorGainMatch = entryStr.match(/gains?\s+(\d+)\s+armor/i);
    if (armorGainMatch) {
      armorGained += parseInt(armorGainMatch[1]);
    }
    
    const armorLossMatch = entryStr.match(/loses?\s+(\d+)\s+armor/i);
    if (armorLossMatch) {
      armorLost += parseInt(armorLossMatch[1]);
    }
  });
  
  return {
    gained: armorGained,
    lost: armorLost,
    net: armorGained - armorLost,
    efficiency: armorGained > 0 ? Math.round((preventedDamage / armorGained) * 100) : 0
  };
}

// Analyze synergies and anti-synergies
function analyzeSynergies(battleResult) {
  const playerItems = getCurrentPlayerItems();
  const synergies = [];
  const antiSynergies = [];
  
  // Detect symphony synergy
  const symphonyItems = playerItems.filter(item => 
    item.tags && item.tags.includes('Symphony')
  );
  if (symphonyItems.length >= 2) {
    synergies.push({
      type: 'Symphony',
      count: symphonyItems.length,
      description: `Symphony chain √ó${symphonyItems.length} (${symphonyItems.map(i => i.name).join(', ')})`,
      items: symphonyItems
    });
  }
  
  // Detect bomb synergy
  const bombItems = playerItems.filter(item => 
    item.tags && item.tags.includes('Bomb')
  );
  if (bombItems.length >= 2) {
    synergies.push({
      type: 'Bomb',
      count: bombItems.length,
      description: `Bomb synergy √ó${bombItems.length} detected`,
      items: bombItems
    });
  }
  
  // Detect potential anti-synergies
  const healingItems = playerItems.filter(item => 
    item.effects && item.effects.some(effect => 
      effect.actions && effect.actions.some(action => 
        action.type && action.type.includes('heal')
      )
    )
  );
  
  if (healingItems.length > 0) {
    // Check for healing blockers (this would need more sophisticated detection)
    antiSynergies.push({
      type: 'Healing Conflict',
      description: 'Healing items present but may be underperforming',
      severity: 'warning'
    });
  }
  
  return { synergies, antiSynergies };
}

// Analyze bottlenecks and risks
function analyzeBottlenecks(battleResult) {
  const bottlenecks = [];
  const risks = [];
  
  // Speed deficit analysis
  const playerStats = calculatePlayerStats();
  const opponentStats = calculateOpponentStats();
  
  if (playerStats.speed < opponentStats.speed) {
    bottlenecks.push({
      type: 'Speed Deficit',
      description: `Speed disadvantage: ${opponentStats.speed - playerStats.speed}`,
      severity: 'high'
    });
  }
  
  // Armor overcap analysis
  if (playerStats.armor > 10) {
    bottlenecks.push({
      type: 'Armor Overcap',
      description: 'Excess armor may indicate inefficient stat distribution',
      severity: 'medium'
    });
  }
  
  // Low HP risk
  if (playerStats.health < 15) {
    risks.push({
      type: 'Low HP',
      description: 'Low health pool increases vulnerability to burst damage',
      severity: 'high'
    });
  }
  
  return { bottlenecks, risks };
}

// Generate recommendations
function generateRecommendations(battleResult) {
  const recommendations = [];
  const analysis = currentBattleAnalysis || {};
  
  // Speed recommendations
  if (analysis.bottlenecks && analysis.bottlenecks.bottlenecks.some(b => b.type === 'Speed Deficit')) {
    recommendations.push({
      title: 'Increase Speed',
      gain: '+2-3 TTK improvement',
      description: 'Consider adding speed items like Swift Boots or Featherweight Helmet to gain turn priority.',
      priority: 'high'
    });
  }
  
  // Synergy recommendations
  const playerItems = getCurrentPlayerItems();
  const symphonyItems = playerItems.filter(item => 
    item.tags && item.tags.includes('Symphony')
  );
  
  if (symphonyItems.length === 1) {
    recommendations.push({
      title: 'Complete Symphony Chain',
      gain: '+15-20% damage boost',
      description: 'Add more Symphony items (Grand Crescendo, Arcane Bell, Sheet Music) to activate synergy bonus.',
      priority: 'medium'
    });
  }
  
  // Generic efficiency recommendation
  recommendations.push({
    title: 'Optimize Item Synergies',
    gain: '+5-10% overall performance',
    description: 'Review item combinations for potential synergies and remove conflicting effects.',
    priority: 'low'
    });
  
  return recommendations.sort((a, b) => {
    const priorityOrder = { high: 3, medium: 2, low: 1 };
    return priorityOrder[b.priority] - priorityOrder[a.priority];
  });
}

// Helper functions
function getCurrentPlayerItems() {
  const items = [];
  
  // Get weapon
  if (sides.P.weapon) {
    items.push(sides.P.weapon);
  }
  
  // Get items
  sides.P.items.forEach(item => {
    if (item) items.push(item);
  });
  
  return items;
}

function calculatePlayerStats() {
  const side = sides.P;
  let hp = side.hpBase, atk = side.atkBase, arm = side.armBase, spd = side.spdBase;
  
  const addStats = obj => {
    if (!obj || !obj.stats) return;
    const s = obj.stats;
    hp += (s.health || 0);
    atk += (s.attack || 0);
    arm += (s.armor || 0);
    spd += (s.speed || 0);
  };
  
  addStats(side.weapon);
  side.items.forEach(addStats);
  
  return { health: hp, attack: atk, armor: arm, speed: spd };
}

function calculateOpponentStats() {
  const side = sides.O;
  let hp = side.hpBase, atk = side.atkBase, arm = side.armBase, spd = side.spdBase;
  
  const addStats = obj => {
    if (!obj || !obj.stats) return;
    const s = obj.stats;
    hp += (s.health || 0);
    atk += (s.attack || 0);
    arm += (s.armor || 0);
    spd += (s.speed || 0);
  };
  
  addStats(side.weapon);
  side.items.forEach(addStats);
  
  return { health: hp, attack: atk, armor: arm, speed: spd };
}

function calculateStrikeUptime(battleResult) {
  // Simplified calculation - would need detailed tracking in actual implementation
  return Math.floor(Math.random() * 100); // Placeholder
}

function calculateNetTempo(battleResult) {
  const playerStats = calculatePlayerStats();
  const opponentStats = calculateOpponentStats();
  return playerStats.speed - opponentStats.speed;
}

// Render the complete battle analysis
function renderBattleAnalysis(analysis) {
  renderOutcomeKPIs(analysis.outcome);
  renderDamageSources(analysis.damageSources);
  renderStatusImpact(analysis.statusImpact);
  renderTriggerHeatmap(analysis.triggerHeatmap);
  renderArmorEconomy(analysis.armorEconomy);
  renderSynergyAnalysis(analysis.synergies);
  renderBottlenecks(analysis.bottlenecks);
  renderRecommendations(analysis.recommendations);
}

// Render outcome KPIs
function renderOutcomeKPIs(outcome) {
  document.getElementById('kpiTTK').textContent = `${outcome.ttk} turns`;
  document.getElementById('kpiSurvived').textContent = outcome.survived ? 'Yes' : 'No';
  document.getElementById('kpiDamageDealt').textContent = outcome.damageDealt;
  document.getElementById('kpiDamageTaken').textContent = outcome.damageTaken;
  document.getElementById('kpiStrikeUptime').textContent = `${outcome.strikeUptime}%`;
  document.getElementById('kpiNetTempo').textContent = outcome.netTempo >= 0 ? `+${outcome.netTempo}` : outcome.netTempo;
  
  // Color coding
  const survivedEl = document.getElementById('kpiSurvived');
  survivedEl.style.color = outcome.survived ? '#26de81' : '#ff6b6b';
  
  const tempoEl = document.getElementById('kpiNetTempo');
  tempoEl.style.color = outcome.netTempo >= 0 ? '#26de81' : '#ff6b6b';
}

// Render damage sources
function renderDamageSources(damageSources) {
  const chartEl = document.getElementById('damageChart');
  const listEl = document.getElementById('damageList');
  
  chartEl.innerHTML = '';
  listEl.innerHTML = '';
  
  if (!damageSources || !damageSources.sources.length) {
    listEl.innerHTML = '<div style="color: #666; font-style: italic;">No damage data available</div>';
    return;
  }
  
  const maxDamage = Math.max(...damageSources.sources.map(s => s.damage));
  
  damageSources.sources.forEach(source => {
    // Create chart bar
    const bar = document.createElement('div');
    bar.className = 'damage-bar';
    const width = maxDamage > 0 ? (source.damage / maxDamage) * 100 : 0;
    bar.innerHTML = `
      <div class="damage-bar-fill" style="width: ${width}%;"></div>
      <span>${source.name}: ${source.damage}</span>
    `;
    chartEl.appendChild(bar);
    
    // Create list item
    const item = document.createElement('div');
    item.className = 'damage-source-item';
    item.innerHTML = `
      <span class="damage-source-name">${source.name}</span>
      <span>
        <span class="damage-source-value">${source.damage}</span>
        <span class="damage-source-percent">(${source.percentage}%)</span>
      </span>
    `;
    
    item.addEventListener('click', () => {
      highlightLogEntries(source.name);
    });
    
    listEl.appendChild(item);
  });
}

// Render status impact
function renderStatusImpact(statusImpact) {
  const container = document.getElementById('statusBreakdown');
  container.innerHTML = '';
  
  if (!statusImpact || Object.keys(statusImpact).length === 0) {
    container.innerHTML = '<div style="color: #666; font-style: italic;">No status effects detected</div>';
    return;
  }
  
  Object.entries(statusImpact).forEach(([status, data]) => {
    const item = document.createElement('div');
    item.className = 'status-impact-item';
    item.innerHTML = `
      <div class="status-impact-header">
        <span class="status-impact-name">${status.charAt(0).toUpperCase() + status.slice(1)}</span>
        <span class="status-impact-total">${data.totalValue}</span>
      </div>
      <div class="status-impact-details">
        ${data.applications} applications, avg ${data.avgValue}, ${data.damage} damage dealt
      </div>
    `;
    container.appendChild(item);
  });
}

// Render trigger heatmap
function renderTriggerHeatmap(heatmapData) {
  const container = document.getElementById('heatmapMatrix');
  container.innerHTML = '<div style="color: #666; font-style: italic;">Trigger heatmap requires detailed simulation tracking</div>';
  
  // This would be implemented with actual simulation data
  // const table = document.createElement('table');
  // table.className = 'heatmap-table';
  // ... table generation code
}

// Render armor economy
function renderArmorEconomy(armorData) {
  const container = document.getElementById('armorFlow');
  container.innerHTML = `
    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; font-size: 12px;">
      <div>
        <div style="color: #26de81; font-weight: bold;">${armorData.gained}</div>
        <div style="color: #aaa;">Gained</div>
      </div>
      <div>
        <div style="color: #ff6b6b; font-weight: bold;">${armorData.lost}</div>
        <div style="color: #aaa;">Lost</div>
      </div>
      <div>
        <div style="color: ${armorData.net >= 0 ? '#26de81' : '#ff6b6b'}; font-weight: bold;">${armorData.net >= 0 ? '+' : ''}${armorData.net}</div>
        <div style="color: #aaa;">Net</div>
      </div>
    </div>
    <div style="margin-top: 8px; font-size: 11px; color: #aaa;">
      Efficiency: ${armorData.efficiency}% damage prevented per armor gained
    </div>
  `;
}

// Render synergy analysis
function renderSynergyAnalysis(synergyData) {
  const calloutsEl = document.getElementById('synergyCallouts');
  const warningsEl = document.getElementById('antiSynergyWarnings');
  
  calloutsEl.innerHTML = '';
  warningsEl.innerHTML = '';
  
  // Render synergies
  if (synergyData.synergies && synergyData.synergies.length > 0) {
    synergyData.synergies.forEach(synergy => {
      const callout = document.createElement('div');
      callout.className = 'synergy-callout';
      callout.innerHTML = `
        <span class="synergy-callout-icon">‚ú®</span>
        <span class="synergy-callout-text">${synergy.description}</span>
      `;
      calloutsEl.appendChild(callout);
    });
  } else {
    calloutsEl.innerHTML = '<div style="color: #666; font-style: italic;">No synergies detected</div>';
  }
  
  // Render anti-synergies
  if (synergyData.antiSynergies && synergyData.antiSynergies.length > 0) {
    synergyData.antiSynergies.forEach(antiSynergy => {
      const warning = document.createElement('div');
      warning.className = 'anti-synergy-warning';
      warning.innerHTML = `
        <span class="anti-synergy-warning-icon">‚ö†Ô∏è</span>
        <span class="anti-synergy-warning-text">${antiSynergy.description}</span>
      `;
      warningsEl.appendChild(warning);
    });
  }
}

// Render bottlenecks
function renderBottlenecks(bottleneckData) {
  const limitingEl = document.getElementById('limitingFactors');
  const risksEl = document.getElementById('riskAlerts');
  
  limitingEl.innerHTML = '';
  risksEl.innerHTML = '';
  
  // Render bottlenecks
  if (bottleneckData.bottlenecks && bottleneckData.bottlenecks.length > 0) {
    bottleneckData.bottlenecks.forEach((bottleneck, index) => {
      const item = document.createElement('div');
      item.style.cssText = 'padding: 8px; background: rgba(255,107,107,0.1); border-radius: 4px; margin-bottom: 6px; font-size: 12px;';
      item.innerHTML = `
        <div style="color: #ff6b6b; font-weight: 500;">#${index + 1} ${bottleneck.type}</div>
        <div style="color: #ccc; margin-top: 2px;">${bottleneck.description}</div>
      `;
      limitingEl.appendChild(item);
    });
  }
  
  // Render risks
  if (bottleneckData.risks && bottleneckData.risks.length > 0) {
    bottleneckData.risks.forEach(risk => {
      const item = document.createElement('div');
      item.style.cssText = 'padding: 6px; background: rgba(255,165,0,0.1); border-radius: 4px; margin-bottom: 4px; font-size: 11px;';
      item.innerHTML = `
        <span style="color: #ffa500; font-weight: 500;">${risk.type}:</span>
        <span style="color: #ccc; margin-left: 4px;">${risk.description}</span>
      `;
      risksEl.appendChild(item);
    });
  }
  
  if (limitingEl.children.length === 0 && risksEl.children.length === 0) {
    limitingEl.innerHTML = '<div style="color: #666; font-style: italic;">No major bottlenecks detected</div>';
  }
}

// Render recommendations
function renderRecommendations(recommendations) {
  const container = document.getElementById('recommendationList');
  container.innerHTML = '';
  
  if (!recommendations || recommendations.length === 0) {
    container.innerHTML = '<div style="color: #666; font-style: italic;">No specific recommendations available</div>';
    return;
  }
  
  recommendations.forEach(rec => {
    const item = document.createElement('div');
    item.className = 'recommendation-item';
    item.innerHTML = `
      <div class="recommendation-header">
        <span class="recommendation-title">${rec.title}</span>
        <span class="recommendation-gain">${rec.gain}</span>
      </div>
      <div class="recommendation-description">${rec.description}</div>
    `;
    container.appendChild(item);
  });
}

// Show empty analysis when no data is available
function showEmptyAnalysis() {
  // Clear all analysis sections
  ['kpiTTK', 'kpiSurvived', 'kpiDamageDealt', 'kpiDamageTaken', 'kpiStrikeUptime', 'kpiNetTempo'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.textContent = '-';
  });
  
  // Show placeholder messages
  const placeholderMessage = '<div style="color: #666; font-style: italic; text-align: center; padding: 20px;">Run a simulation to see battle analysis</div>';
  
  ['damageList', 'statusBreakdown', 'heatmapMatrix', 'armorFlow', 
   'synergyCallouts', 'limitingFactors', 'recommendationList'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.innerHTML = placeholderMessage;
  });
}

// Highlight log entries related to a specific source
function highlightLogEntries(sourceName) {
  if (!currentSimulationLog) return;
  
  // This would highlight relevant log entries in the simulation tab
  console.log('Highlighting log entries for:', sourceName);
  
  // Could also open the why inspector
  showWhyInspector(sourceName);
}

// Show why inspector for detailed analysis
function showWhyInspector(sourceName) {
  const inspector = document.getElementById('whyInspector');
  const causalChain = document.getElementById('causalChain');
  
  // Mock causal chain data
  causalChain.innerHTML = `
    <div class="causal-step">
      <div class="causal-step-header">Source Item ‚Üí Trigger</div>
      <div class="causal-step-details">${sourceName} activated on battle start trigger</div>
    </div>
    <div class="causal-step">
      <div class="causal-step-header">Condition Check</div>
      <div class="causal-step-details">No conditions required - always triggers</div>
    </div>
    <div class="causal-step">
      <div class="causal-step-header">Actions Executed</div>
      <div class="causal-step-details">Deal damage action executed successfully</div>
    </div>
    <div class="causal-step">
      <div class="causal-step-header">State Delta</div>
      <div class="causal-step-details">Enemy HP reduced, battle state updated</div>
    </div>
  `;
  
  inspector.classList.add('open');
}

// Initialize when the page loads
initializeBattleAnalysis();
if (clearBtn) {
  clearBtn.addEventListener('click', () => {
    uiLogClear();
    BattleReplayController.hide(); // Hide replay controls when clearing
  });
}

// Normalize any garbled labels from past encoding issues
(function normalizeLabels(){
  try {
    const ep = document.getElementById('edgeP');
    if (ep && ep.options && ep.options.length) ep.options[0].textContent = '- Select Edge -';
    const eo = document.getElementById('edgeO');
    if (eo && eo.options && eo.options.length) eo.options[0].textContent = '- Select Edge -';
    const rb = document.getElementById('randBuildBtn'); if (rb) rb.textContent = 'Random Build';
    const re = document.getElementById('randEnemyBtn'); if (re) re.textContent = 'Random Enemy';
    const bs = document.getElementById('btnSimulate'); if (bs) bs.textContent = 'Simulate';
  } catch (_) {}
})();

// Import-from-screenshot (alpha) removed
/*
(function setupImport(){
  const drop = document.getElementById('importDrop');
  const canvas = document.getElementById('importCanvas');
  const ctx = canvas ? canvas.getContext('2d') : null;
  const srcCanvas = document.createElement('canvas');
  const srcCtx = srcCanvas.getContext('2d');
  const logEl = document.getElementById('importLog');
  const fileBtn = document.getElementById('btnLoadImage');
  const fileInput = document.getElementById('imageFile');
  const btnScan = document.getElementById('btnScan');
  const btnApplyBoth = document.getElementById('btnApplyBoth');
  const roiTarget = document.getElementById('roiTarget');
  const roiRows = document.getElementById('roiRows');
  const roiCols = document.getElementById('roiCols');
  const confMinInput = document.getElementById('confMin');
  const chkPreview = document.getElementById('chkPreview');
  const chkOcrEdge = document.getElementById('chkOcrEdge');
  const warnEl = document.getElementById('importWarnings');
  if (!drop || !canvas || !ctx) return;

  const ROIS = { 'left-items': null, 'left-weapon': null, 'left-oils': null, 'left-edge': null, 'right-items': null, 'right-weapon': null, 'right-oils': null, 'right-edge': null };
  let clickStart = null;
  let img = new Image();
  let iconLib = null;
  let oilsLib = null; // attack/armor/speed icons
  let lastHints = [];
  let dragging = null; // {target, kind:'nw'|'ne'|'sw'|'se', ox, oy}
  let warnings = [];
  let presetSide = null; // 'P' | 'O' when preset mode active

  function log(msg){ if (logEl) logEl.textContent += (msg+'\n'); }
  function clearLog(){ if (logEl) logEl.textContent=''; }
  function render(){
    if (!img || !img.width) return;
    const W = canvas.clientWidth|0; const ratio = img.height/img.width; canvas.width = W; canvas.height = Math.max(1, Math.floor(W*ratio));
    ctx.imageSmoothingEnabled = false; ctx.drawImage(srcCanvas && srcCanvas.width ? srcCanvas : img, 0, 0, canvas.width, canvas.height);
    const drawRect = (r, color, withGrid=false, rows=0, cols=0) => {
      if(!r) return; ctx.strokeStyle=color; ctx.lineWidth=2; ctx.strokeRect(r.x, r.y, r.w, r.h);
      if (withGrid && rows>0 && cols>0) {
        ctx.save(); ctx.strokeStyle = color; ctx.globalAlpha = 0.4; ctx.lineWidth = 1;
        const cw = r.w/cols, ch = r.h/rows;
        for (let i=1;i<cols;i++){ ctx.beginPath(); ctx.moveTo(r.x+i*cw, r.y); ctx.lineTo(r.x+i*cw, r.y+r.h); ctx.stroke(); }
        for (let j=1;j<rows;j++){ ctx.beginPath(); ctx.moveTo(r.x, r.y+j*ch); ctx.lineTo(r.x+r.w, r.y+j*ch); ctx.stroke(); }
        ctx.restore();
      }
      // draw handles if this is the active target
      if (roiTarget.value && ROIS[roiTarget.value] === r) {
        const hs = 6; const pts = [[r.x,r.y],[r.x+r.w,r.y],[r.x,r.y+r.h],[r.x+r.w,r.y+r.h]];
        ctx.fillStyle = color; for (const [px,py] of pts){ ctx.fillRect(px-hs/2, py-hs/2, hs, hs); }
      }
    };
    drawRect(ROIS['left-items'], '#0f0', roiTarget.value==='left-items', ROIS['left-items']?.rows||0, ROIS['left-items']?.cols||0);
    drawRect(ROIS['left-weapon'], '#0f0');
    drawRect(ROIS['left-oils'], '#0f0', roiTarget.value==='left-oils', ROIS['left-oils']?.rows||0, ROIS['left-oils']?.cols||0);
    drawRect(ROIS['left-edge'], '#0f0');
    drawRect(ROIS['right-items'], '#f00', roiTarget.value==='right-items', ROIS['right-items']?.rows||0, ROIS['right-items']?.cols||0);
    drawRect(ROIS['right-weapon'], '#f00');
    drawRect(ROIS['right-oils'], '#f00', roiTarget.value==='right-oils', ROIS['right-oils']?.rows||0, ROIS['right-oils']?.cols||0);
    drawRect(ROIS['right-edge'], '#f00');
    // overlay hints
    ctx.save();
    ctx.font = '12px monospace';
    for (const h of lastHints){
      ctx.strokeStyle = h.color || '#fff'; ctx.lineWidth=1; ctx.globalAlpha=0.85; ctx.strokeRect(h.x, h.y, h.w, h.h);
      const label = `${h.name||h.slug} (${h.conf||0}%)`;
      const pad=2; const tw = ctx.measureText(label).width + 2*pad; const th = 14 + 2*pad;
      ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(h.x, Math.max(0,h.y- (th+1)), tw, th);
      ctx.fillStyle = h.color || '#fff'; ctx.fillText(label, h.x+pad, Math.max(12, h.y-4));
    }
    ctx.restore();
  }
  async function loadImageFile(f){ return new Promise((resolve,reject)=>{ const fr=new FileReader(); fr.onload=()=>{ img=new Image(); img.onload=()=>{ try{ srcCanvas.width = img.naturalWidth || img.width; srcCanvas.height = img.naturalHeight || img.height; srcCtx.imageSmoothingEnabled = false; srcCtx.drawImage(img, 0, 0); } catch(_){ } render(); resolve(); }; img.src=fr.result; }; fr.onerror=reject; fr.readAsDataURL(f); }); }
  drop.addEventListener('dragover', e => { e.preventDefault(); drop.style.background='#112'; });
  drop.addEventListener('dragleave', e => { drop.style.background=''; });
  drop.addEventListener('drop', async e => { e.preventDefault(); drop.style.background=''; const f=e.dataTransfer.files&&e.dataTransfer.files[0]; if(f){ clearLog(); await loadImageFile(f); log('Image loaded. Drag to draw rectangles.'); } });
  document.addEventListener('paste', async e => { const it=(e.clipboardData||{}).items||[]; for(const i of it){ if(i.type && i.type.indexOf('image')===0){ const f=i.getAsFile(); clearLog(); await loadImageFile(f); log('Image pasted.'); break; } } });
  if (fileBtn && fileInput) { fileBtn.addEventListener('click', ()=>fileInput.click()); fileInput.addEventListener('change', async ()=>{ const f=fileInput.files[0]; if(f){ clearLog(); await loadImageFile(f); log('Image loaded.'); } }); }
  // Simple calibrator: drag handles at corners, or drag to create a new ROI
  canvas.addEventListener('mousedown', e => {
    const rect=canvas.getBoundingClientRect(); const x=Math.round(e.clientX-rect.left), y=Math.round(e.clientY-rect.top);
    // Preset mode: draw one rectangle for panel bounds
    if (presetSide){
      dragging = { target: '_preset_', kind: 'new', ox:x, oy:y, start: { x:x, y:y, w:1, h:1 } };
      ROIS._presetPreview = { x:x, y:y, w:1, h:1 };
      render();
      return;
    }
    if (QUICK.active){
      dragging = { target: '_quick_', kind:'new', ox:x, oy:y, start:{ x:x, y:y, w:1, h:1 } };
      ROIS._presetPreview = { x:x, y:y, w:1, h:1 };
      render();
      return;
    }
    const t=roiTarget.value; const r=ROIS[t]; const hs=8;
    if (r) {
      const corners=[{k:'nw',x:r.x,y:r.y},{k:'ne',x:r.x+r.w,y:r.y},{k:'sw',x:r.x,y:r.y+r.h},{k:'se',x:r.x+r.w,y:r.y+r.h}];
      for(const c of corners){ if (Math.abs(x-c.x)<=hs && Math.abs(y-c.y)<=hs){ dragging={target:t, kind:c.k, ox:x, oy:y, start: {...r} }; return; } }
    }
    // Not on a handle (or ROI not defined): begin creating a fresh ROI
    dragging={ target:t, kind:'new', ox:x, oy:y, start:{ x:x, y:y, w:1, h:1 } };
    ROIS[t] = { x:x, y:y, w:1, h:1, rows: parseInt(roiRows.value,10)||12, cols: parseInt(roiCols.value,10)||1 };
    render();
  });
  canvas.addEventListener('mousemove', e => {
    if (!dragging) return; const rect=canvas.getBoundingClientRect(); const x=Math.round(e.clientX-rect.left), y=Math.round(e.clientY-rect.top);
    const t=dragging.target; const r={...dragging.start};
    if (t==='_preset_'){
      r.w = x - r.x; r.h = y - r.y; r.w=Math.max(4,r.w); r.h=Math.max(4,r.h); ROIS._presetPreview = r; render(); return;
    }
    if (t==='_quick_'){
      r.w = x - r.x; r.h = y - r.y; r.w=Math.max(4,r.w); r.h=Math.max(4,r.h); ROIS._presetPreview = r; render(); return;
    }
    if (dragging.kind==='nw'){ r.w += r.x - x; r.h += r.y - y; r.x=x; r.y=y; }
    if (dragging.kind==='ne'){ r.w = x - r.x; r.h += r.y - y; r.y=y; }
    if (dragging.kind==='sw'){ r.w += r.x - x; r.x=x; r.h = y - r.y; }
    if (dragging.kind==='se' || dragging.kind==='new'){ r.w = x - r.x; r.h = y - r.y; }
    r.w=Math.max(4,r.w); r.h=Math.max(4,r.h); ROIS[t]=Object.assign(r,{ rows:ROIS[t].rows, cols:ROIS[t].cols }); render();
  });
  document.addEventListener('mouseup', ()=> {
    if (dragging && dragging.target === '_preset_' && ROIS._presetPreview) {
      const r = ROIS._presetPreview; delete ROIS._presetPreview; dragging=null; if (presetSide) { applyPanelPreset(presetSide, r); presetSide=null; const ph=document.getElementById('presetHint'); if(ph) ph.textContent=''; return; } }
    if (dragging && dragging.target === '_wiz_' && ROIS._presetPreview) {
      const r = ROIS._presetPreview; delete ROIS._presetPreview; dragging=null; if (WIZ && WIZ.active) { onWizardRect(r); return; } }
    if (dragging && dragging.target === '_quick_' && ROIS._presetPreview) {
      const r = ROIS._presetPreview; delete ROIS._presetPreview; dragging=null; if (QUICK && QUICK.active) { onQuickWeaponRect(r); return; } }
    dragging=null;
  });
  function toGray(data){ const out=new Float32Array(data.length/4); for(let i=0,j=0;i<data.length;i+=4,j++){ out[j]=(0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]); } return out; }
  function hashFromCanvas(csrc){ const N=16; const c2=document.createElement('canvas'); c2.width=N; c2.height=N; const cx2=c2.getContext('2d'); cx2.imageSmoothingEnabled=true; cx2.drawImage(csrc,0,0,N,N); const d=cx2.getImageData(0,0,N,N).data; const g=toGray(d); let mean=0; for(let i=0;i<g.length;i++) mean+=g[i]; mean/=g.length; let sd=0; for(let i=0;i<g.length;i++){ const v=g[i]-mean; sd+=v*v; } sd=Math.sqrt(sd/g.length)||1; for(let i=0;i<g.length;i++) g[i]=(g[i]-mean)/sd; return g; }
  function loadCache(){ try { const meta=JSON.parse(localStorage.getItem('HEIC_FP_META')||'null'); const data=JSON.parse(localStorage.getItem('HEIC_FPCACHE_V1')||'null'); if(!meta||!data) return null; const expect=Object.keys(RAW_DATA||{}).filter(k=>/(^items\/|^weapons\/|^upgrades\/)/.test(k)).length; if (meta.len!==expect) return null; return data; } catch(_){ return null; } }
// Persist the fingerprint library to localStorage.
// Use a multi‚Äëline implementation here rather than a heavily minified one to
// avoid parser confusion from comment delimiters and regular expressions.  See
// https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage for API
// details.
function saveCache(list) {
  try {
    // Count how many fingerprintable entries exist in RAW_DATA.  Only items,
    // weapons and upgrades are considered for the cache.
    const len = Object.keys(RAW_DATA || {}).filter(k => {
      return /(^items\/|^weapons\/|^upgrades\/)/.test(k);
    }).length;
    // Store a small meta record with a version and the expected length.  This
    // allows us to detect stale caches later on.
    localStorage.setItem('HEIC_FP_META', JSON.stringify({ v: 1, len }));
    // Persist the fingerprint list itself under a separate key.
    localStorage.setItem('HEIC_FPCACHE_V1', JSON.stringify(list));
  } catch (e) {
    // Intentionally ignore any storage errors (quota exceeded, disabled, etc).
    // Swallowing exceptions here prevents the cache failure from breaking the UI.
  }
}
  async function buildIconLib(){
    if(iconLib) return iconLib;
    const cached=loadCache();
    if (cached) { iconLib=cached; log(`Icon library loaded from cache (${iconLib.length}).`); return iconLib; }
    const list=[];
    for(const [k,v] of Object.entries(RAW_DATA||{})){
      if(!/(^items\/|^weapons\/|^upgrades\/)/.test(k)) continue;
      // Try key path first, then bucket/slug
      const candidates = [];
      candidates.push(`${k}/icon.png`);
      if (v && v.bucket && v.slug) candidates.push(`${v.bucket}/${v.slug}/icon.png`);
      let okPath=null;
      for (const p of candidates){
        const im=new Image();
        await new Promise(res=>{ im.onload=res; im.onerror=res; im.src=p; });
        if (im.width){ okPath=p; break; }
      }
      if (!okPath) continue;
      const tmp=document.createElement('canvas'); tmp.width=32; tmp.height=32; const tx=tmp.getContext('2d'); tx.imageSmoothingEnabled=false; tx.drawImage(im,0,0,tmp.width,tmp.height); const fp=hashFromCanvas(tmp);
      list.push({ slug:k, fp, path: okPath });
    }
    iconLib=list; saveCache(list); log(`Icon library ready (${list.length}).`); return iconLib;
  }
  async function buildOilsLib(){ if (oilsLib) return oilsLib; const entries=[{slug:'oil-attack',path:'assets/attack.png',kind:'attack'},{slug:'oil-armor',path:'assets/armor.png',kind:'armor'},{slug:'oil-speed',path:'assets/speed.png',kind:'speed'}]; const out=[]; for(const e of entries){ const im=new Image(); await new Promise(res=>{ im.onload=res; im.onerror=res; im.src=e.path; }); const tmp=document.createElement('canvas'); tmp.width=im.width||22; tmp.height=im.height||22; const tx=tmp.getContext('2d'); tx.imageSmoothingEnabled=false; tx.drawImage(im,0,0,tmp.width,tmp.height); const fp=hashFromCanvas(tmp); out.push({ slug:e.slug, fp, path:e.path, kind:e.kind }); } oilsLib=out; return out; }
  function viewToSrcRect(x,y,w,h){ if (!srcCanvas.width || !canvas.width) return {sx:0,sy:0,sw:1,sh:1}; const sx = Math.max(0, Math.round(x * srcCanvas.width / canvas.width)); const sy = Math.max(0, Math.round(y * srcCanvas.height / canvas.height)); const sw = Math.max(1, Math.round(w * srcCanvas.width / canvas.width)); const sh = Math.max(1, Math.round(h * srcCanvas.height / canvas.height)); return {sx,sy,sw,sh}; }
  function cropHash(x,y,w,h){ const r=viewToSrcRect(x,y,w,h); const tmp=document.createElement('canvas'); tmp.width=Math.max(1,r.sw); tmp.height=Math.max(1,r.sh); const tx=tmp.getContext('2d'); tx.imageSmoothingEnabled=true; tx.drawImage(srcCanvas,r.sx,r.sy,r.sw,r.sh,0,0,tmp.width,tmp.height); return hashFromCanvas(tmp); }
  function dist(a,b){ let s=0; for(let i=0;i<64;i++){ const d=a[i]-b[i]; s+=d*d; } return s; }
  function toConf(d){ const alpha=0.08; return Math.max(1, Math.min(99, Math.round(100*Math.exp(-alpha*d)))) }
  async function scanAndApply(){ await buildIconLib(); await buildOilsLib(); lastHints.length=0; warnings.length=0; const picks={ left:{items:[],weapon:null,oils:new Set(),edge:null}, right:{items:[],weapon:null,oils:new Set(),edge:null} }; const addHint=(x,y,w,h,slug,conf,color)=>{ const rec={x,y,w,h,slug,conf,color,name:(RAW_DATA[slug]?.name)||slug}; lastHints.push(rec); const min = parseInt(confMinInput?.value||'60',10)||60; if (conf < min) { warnings.push(`${slug} @ ${Math.round(conf)}% (ROI ${x},${y},${w}x${h})`); } };
    const processGrid=(roi,sideKey,isItems=true)=>{ if(!roi) return; const {x,y,w,h,rows,cols}=roi; const cw=Math.floor(w/cols), ch=Math.floor(h/rows); const padPctEl = document.getElementById('padPct'); const pct = Math.max(0, Math.min(40, parseInt(padPctEl?.value||'18',10)||18))/100; const shrink = (cx,cy,cw,ch) => { const pad=Math.floor(Math.min(cw,ch)*pct); return [cx+pad, cy+pad, Math.max(2,cw-2*pad), Math.max(2,ch-2*pad)]; }; for(let r=0;r<rows;r++){ for(let c=0;c<cols;c++){ const cx=x+c*cw, cy=y+r*ch; const [sx,sy,sw,sh]=shrink(cx,cy,cw,ch); const fp=cropHash(sx,sy,sw,sh); let best=null, bd=1e9; const lib=isItems?iconLib:oilsLib; for(const it of lib){ const d=dist(fp,it.fp); if(d<bd){ bd=d; best=it; } } const conf = toConf(bd); if(best){ if (isItems) { if (conf >= (parseInt(confMinInput?.value||'60',10)||60)) (sideKey==='P'?picks.left.items:picks.right.items).push(best.slug); addHint(sx,sy,sw,sh,best.slug,conf, sideKey==='P'?'#0f0':'#f00'); } else { const kind=best.kind; (sideKey==='P'?picks.left.oils:picks.right.oils).add(kind); addHint(sx,sy,sw,sh,kind, conf, sideKey==='P'?'#0f0':'#f00'); } } } } };
    const processRect=(roi,sideKey,onlyWeapons=false,onlyUpgrades=false)=>{ if(!roi) return; const padPctEl=document.getElementById('padPct'); const pct = Math.max(0, Math.min(40, parseInt(padPctEl?.value||'18',10)||18))/100; const pad=Math.floor(Math.min(roi.w,roi.h)*pct); const sx=roi.x+pad, sy=roi.y+pad, sw=Math.max(2,roi.w-2*pad), sh=Math.max(2,roi.h-2*pad); const fp=cropHash(sx,sy,sw,sh); let best=null, bd=1e9; for(const it of iconLib){ if (onlyWeapons && !/^weapons\//.test(it.slug)) continue; if (onlyUpgrades && !/^upgrades\//.test(it.slug)) continue; const d=dist(fp,it.fp); if(d<bd){ bd=d; best=it; } } const conf=toConf(bd); if(best){ if(onlyWeapons){ if(conf >= (parseInt(confMinInput?.value||'60',10)||60)) { if(sideKey==='P') picks.left.weapon=best.slug; else picks.right.weapon=best.slug; } } if(onlyUpgrades){ if(conf >= (parseInt(confMinInput?.value||'60',10)||60)) { if(sideKey==='P') picks.left.edge=best.slug; else picks.right.edge=best.slug; } } addHint(sx,sy,sw,sh,best.slug,conf, sideKey==='P'?'#0f0':'#f00'); } };

    // Optional OCR for edge slugs
    async function ensureTesseract(){ if (window.Tesseract) return; await new Promise((res)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/tesseract.js@v5.0.2/dist/tesseract.min.js'; s.onload=res; s.onerror=res; document.body.appendChild(s); }); }
    function lev(a,b){ a=a.toLowerCase(); b=b.toLowerCase(); const m=a.length,n=b.length; const dp=Array.from({length:m+1},()=>Array(n+1).fill(0)); for(let i=0;i<=m;i++) dp[i][0]=i; for(let j=0;j<=n;j++) dp[0][j]=j; for(let i=1;i<=m;i++){ for(let j=1;j<=n;j++){ dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+(a[i-1]===b[j-1]?0:1)); } } return dp[m][n]; }
    function bestByText(text){ if(!text) return null; const names=[]; for(const [k,v] of Object.entries(RAW_DATA||{})){ if(/^upgrades\//.test(k)) names.push({slug:k, name: (v.name||k)}); } const t=text.trim().toLowerCase(); let best=null, bs=-1; for(const e of names){ const s=1 - (lev(t, e.name.toLowerCase()) / Math.max(t.length, e.name.length)); if (s>bs){ bs=s; best=e; } } return best ? { slug:best.slug, sim:best ? Math.round(best && (1 - (lev(t, best.name.toLowerCase()) / Math.max(t.length,best.name.length))) * 100) : 0 } : null; }
    async function tryOcrEdge(roi, sideKey){ if (!roi || !chkOcrEdge?.checked) return null; try { await ensureTesseract(); if (!window.Tesseract) return null; const tmp=document.createElement('canvas'); tmp.width=Math.max(1,roi.w); tmp.height=Math.max(1,roi.h); const tx=tmp.getContext('2d'); tx.drawImage(canvas, roi.x, roi.y, roi.w, roi.h, 0,0,tmp.width,tmp.height); const dataUrl=tmp.toDataURL(); const res= await window.Tesseract.recognize(dataUrl,'eng'); const text=(res && res.data && res.data.text || '').replace(/\s+/g,' ').trim(); if (!text) return null; const best=bestByText(text); if (best && best.slug){ addHint(roi.x,roi.y,roi.w,roi.h,best.slug,best.sim, sideKey==='P'?'#0f0':'#f00'); return best.slug; } } catch(_){} return null; }
    // items & weapons
    processGrid(ROIS['left-items'],'P',true); processRect(ROIS['left-weapon'],'P',true,false);
    processGrid(ROIS['right-items'],'O',true); processRect(ROIS['right-weapon'],'O',true,false);
    // oils
    processGrid(ROIS['left-oils'],'P',false); processGrid(ROIS['right-oils'],'O',false);
    // edges (if icons exist)
    processRect(ROIS['left-edge'],'P',false,true); processRect(ROIS['right-edge'],'O',false,true);
    // OCR fallback for edges
    const lOcr = await tryOcrEdge(ROIS['left-edge'],'P'); if (lOcr) picks.left.edge = lOcr;
    const rOcr = await tryOcrEdge(ROIS['right-edge'],'O'); if (rOcr) picks.right.edge = rOcr;
    render();
  function applySide(key,pred){ const side=key==='P'?sides.P:sides.O; const wSlot=key==='P'?document.getElementById('weaponP'):document.getElementById('weaponO'); if(pred.weapon && RAW_DATA[pred.weapon]){ side.weapon=RAW_DATA[pred.weapon]; if(wSlot) wSlot.innerHTML=mini(side.weapon); }
  const gridEl=key==='P'?document.getElementById('gridP'):document.getElementById('gridO'); const cells=gridEl?gridEl.querySelectorAll('.slot'):[]; const list=(pred.items||[]).filter(s=>/^items\//.test(s)).slice(0,SLOT_COUNT); for(let i=0;i<SLOT_COUNT;i++){ const slug=list[i]; const cell=cells[i]; if(slug && RAW_DATA[slug]){ const it=RAW_DATA[slug]; side.items[i]=it; if(cell){ cell.classList.add('filled'); cell.innerHTML=mini(it); } } else { side.items[i]=null; if(cell){ cell.classList.remove('filled'); cell.innerHTML=''; } } } updateTotals(key); }
    function applyOils(key,set){ const box = key==='P'?document.getElementById('oilsP'):document.getElementById('oilsO'); const kinds=['attack','armor','speed']; if (box){ kinds.forEach(k=>{ const el = box.querySelector(`.oil[data-kind="${k}"]`); if (el){ if (set.has(k)) el.classList.add('active'); else el.classList.remove('active'); } }); } const side = key==='P'?sides.P:sides.O; side.oils = new Set(set); updateTotals(key); }
  function applyEdge(key, slug){ if (!slug || !RAW_DATA[slug]) return; const side = key==='P'?sides.P:sides.O; side.edge = RAW_DATA[slug]; const sel = key==='P'?document.getElementById('edgeP'):document.getElementById('edgeO'); const eff = key==='P'?document.getElementById('edgePEffect'):document.getElementById('edgeOEffect'); const ic = key==='P'?document.getElementById('edgePIcon'):document.getElementById('edgeOIcon'); if (sel){ sel.value = side.edge.slug; } if (eff){ eff.textContent = side.edge.effect || ''; } if (ic){ const cands=resolveIconCandidates(side.edge); let i=0; ic.src=cands[i]||'placeholder.png'; ic.onerror=()=>{ i+=1; if(i<cands.length){ ic.src=cands[i]; } else { ic.onerror=null; ic.src='placeholder.png'; } }; } updateTotals(key); }
    // Fill warnings list
    if (warnEl){ warnEl.textContent = warnings.length ? ('Low-confidence matches:\n- ' + warnings.join('\n- ')) : 'No low-confidence matches.'; }
    // Preview-only toggle
    const preview = !!(chkPreview && chkPreview.checked);
    if (!preview){
      applySide('P',{weapon:picks.left.weapon,items:picks.left.items}); applySide('O',{weapon:picks.right.weapon,items:picks.right.items});
      applyOils('P', picks.left.oils||new Set()); applyOils('O', picks.right.oils||new Set());
      if (picks.left.edge) applyEdge('P', picks.left.edge);
      if (picks.right.edge) applyEdge('O', picks.right.edge);
      log('Applied best matches.');
    } else {
      log('Preview only: not applied.');
    }
  }
  if(btnScan) btnScan.addEventListener('click', scanAndApply); if(btnApplyBoth) btnApplyBoth.addEventListener('click', scanAndApply);
  // Preset buttons
  const presetHint = document.getElementById('presetHint');
  const btnPresetLeft = document.getElementById('btnPresetLeft');
  const btnPresetRight = document.getElementById('btnPresetRight');
  const btnQuickLeft = document.getElementById('btnQuickLeft');
  const btnQuickRight = document.getElementById('btnQuickRight');
  const quickHint = document.getElementById('quickHint');
  const QUICK = { active:false, side:null };
  function applyPanelPreset(sideKey, panel){
    // Normalize rect (ensure positive w/h)
    let x=panel.x, y=panel.y, w=panel.w, h=panel.h; if (w<0){ x+=w; w=-w; } if (h<0){ y+=h; h=-h; }
    const mX = Math.round(w * 0.10), mTop = Math.round(h * 0.06), mBot = Math.round(h * 0.06);
    const tile = Math.round(h * 0.06 * 1.6); // approx tile based on height
    // Weapon
    const wX = x + Math.round((w - tile)/2);
    const wY = y + mTop;
    const weapon = { x: wX, y: wY, w: tile, h: tile };
    // Items grid (12x1), square tiles snapped
    const itemsH = tile * 12;
    const itemsY = Math.min(y + h - mBot - itemsH, wY + tile + Math.round(h*0.08));
    const itemsX = x + Math.round((w - tile)/2);
    const items = { x: itemsX, y: itemsY, w: tile, h: itemsH, rows:12, cols:1 };
    // Oils row below weapon
    const oilsH = Math.round(tile * 3);
    const oilsY = Math.min(itemsY - Math.round(h*0.02) - oilsH, y + wY + tile + Math.round(h*0.02));
    const oils = { x: itemsX, y: oilsY, w: tile, h: oilsH, rows:3, cols:1 };
    // Edge box to the right of oils (optional)
    const edge = { x: itemsX + tile + Math.round(w*0.04), y: oilsY, w: tile, h: tile };
    const L = (k,obj)=>{ ROIS[(sideKey==='P'?'left':'right')+'-'+k] = obj; };
    L('weapon', weapon); L('items', items); L('oils', oils); L('edge', edge);
    render();
    // Switch target to items for quick tweaks
    roiTarget.value = (sideKey==='P') ? 'left-items' : 'right-items';
    // run preview
    scanAndApply();
  }
  if (btnPresetLeft) btnPresetLeft.addEventListener('click', ()=>{ presetSide='P'; if(presetHint) presetHint.textContent='Draw a rectangle around the LEFT panel'; });
  if (btnPresetRight) btnPresetRight.addEventListener('click', ()=>{ presetSide='O'; if(presetHint) presetHint.textContent='Draw a rectangle around the RIGHT panel'; });
  if (btnQuickLeft) btnQuickLeft.addEventListener('click', ()=>{ QUICK.active=true; QUICK.side='P'; if (quickHint) quickHint.textContent='LEFT: Draw the WEAPON tile only'; });
  if (btnQuickRight) btnQuickRight.addEventListener('click', ()=>{ QUICK.active=true; QUICK.side='O'; if (quickHint) quickHint.textContent='RIGHT: Draw the WEAPON tile only'; });
  const wizardHint = document.getElementById('wizardHint');
  const btnWizardLeft = document.getElementById('btnWizardLeft');
  const btnWizardRight = document.getElementById('btnWizardRight');
  const btnWizardNext = document.getElementById('btnWizardNext');
  const btnWizardCancel = document.getElementById('btnWizardCancel');
  const WIZ = { active:false, side:null, step:0, rects:{} };
  function wizSetHint(){
    const s = WIZ.side==='P'?'LEFT':'RIGHT';
    const map = { 1:`${s}: Draw panel bounds`, 2:`${s}: Draw WEAPON tile`, 3:`${s}: Draw ITEM tile row #1`, 4:`${s}: Draw ITEM tile row #2 (one below)`, 5:`${s}: Draw OILS tile (optional) or press Next`, 6:`${s}: Draw EDGE box (optional) or press Next` };
    if (wizardHint) wizardHint.textContent = map[WIZ.step] || '';
  }
  function startWizard(side){ WIZ.active=true; WIZ.side=side; WIZ.step=1; WIZ.rects={}; wizSetHint(); }
  if (btnWizardLeft) btnWizardLeft.addEventListener('click', ()=> startWizard('P'));
  if (btnWizardRight) btnWizardRight.addEventListener('click', ()=> startWizard('O'));
  if (btnWizardCancel) btnWizardCancel.addEventListener('click', ()=> { WIZ.active=false; WIZ.side=null; WIZ.step=0; WIZ.rects={}; if(wizardHint) wizardHint.textContent=''; });
  if (btnWizardNext) btnWizardNext.addEventListener('click', ()=> { if (!WIZ.active) return; onWizardRect(null); });
  function onWizardRect(rect){ if (!WIZ.active) return; const sKey=(WIZ.side==='P')?'left':'right'; const norm=(r)=>{ if(!r) return null; let {x,y,w,h}=r; if(w<0){x+=w;w=-w;} if(h<0){y+=h;h=-h;} return {x,y,w,h}; };
    if (WIZ.step===1){ WIZ.rects.panel=norm(rect); WIZ.step=2; wizSetHint(); return; }
    if (WIZ.step===2){ WIZ.rects.weapon=norm(rect); WIZ.step=3; wizSetHint(); return; }
    if (WIZ.step===3){ WIZ.rects.item1=norm(rect); WIZ.step=4; wizSetHint(); return; }
    if (WIZ.step===4){ WIZ.rects.item2=norm(rect); WIZ.step=5; wizSetHint(); return; }
    if (WIZ.step===5){ WIZ.rects.oils=norm(rect); WIZ.step=6; wizSetHint(); return; }
    if (WIZ.step===6){ WIZ.rects.edge=norm(rect); WIZ.step=7; }
    const it1=WIZ.rects.item1, it2=WIZ.rects.item2; const weapon=WIZ.rects.weapon; if (it1 && it2){ const step=Math.max(8, Math.round(it2.y - it1.y)); const tileW=it1.w; ROIS[`${sKey}-items`] = { x:it1.x, y:it1.y, w:tileW, h:step*12, rows:12, cols:1 }; }
    if (weapon) ROIS[`${sKey}-weapon`]=weapon; if (WIZ.rects.oils) ROIS[`${sKey}-oils`]=Object.assign({},WIZ.rects.oils,{rows:3,cols:1}); if (WIZ.rects.edge) ROIS[`${sKey}-edge`]=WIZ.rects.edge; WIZ.active=false; WIZ.step=0; wizSetHint(); render(); scanAndApply(); }

  // Quick mode: build a 12√ó1 grid from a single weapon-tile rectangle
  function onQuickWeaponRect(rect){
    if (!QUICK.active || !rect) { QUICK.active=false; if (quickHint) quickHint.textContent=''; return; }
    let {x,y,w,h}=rect; if (w<0){x+=w;w=-w;} if (h<0){y+=h;h=-h;}
    const s = Math.min(w,h); // enforce square
    const sideKey = (QUICK.side==='P') ? 'left' : 'right';
    ROIS[`${sideKey}-weapon`] = { x:x, y:y, w:s, h:s };
    // scan for first item frame directly below weapon using edge brightness on full-res image
    const scoreAt = (ty)=>{ let sum=0, cnt=0; try{ const r=viewToSrcRect(x, ty, s, s); const sw=r.sw, sh=r.sh; const img=srcCtx.getImageData(r.sx, r.sy, sw, sh).data; const idx=(px,py)=>{ const i=(py*sw+px)*4; return img[i]+img[i+1]+img[i+2]; }; for(let px=2; px<sw-2; px+=Math.max(2, Math.floor(sw/24))){ sum+=idx(px,2)+idx(px,3)+idx(px,sh-3)+idx(px,sh-2); cnt+=4; } for(let py=2; py<sh-2; py+=Math.max(2, Math.floor(sh/24))){ sum+=idx(2,py)+idx(3,py)+idx(sw-3,py)+idx(sw-2,py); cnt+=4; } }catch(_){ } return cnt?sum/cnt:0; };
    const start = y + s + Math.floor(s*0.05), end = start + Math.floor(s*2.2); let bestY=start, best= -1; for(let ty=start; ty<=end; ty+=2){ const sc=scoreAt(ty); if(sc>best){ best=sc; bestY=ty; } }
    const gap = Math.max(4, bestY - (y+s)); const step = s + gap;
    // derive rows (max 12) until canvas bottom
    let rows=0; while (rows<12 && (bestY + rows*step + s) <= canvas.height) rows++;
    if (rows < 1) rows = 10; // fallback
    ROIS[`${sideKey}-items`] = { x:x, y:bestY, w:s, h:step*rows, rows:rows, cols:1 };
    QUICK.active=false; if (quickHint) quickHint.textContent=''; render(); scanAndApply();
  }

  // Presets for rows/cols by target type
  roiTarget.addEventListener('change', () => {
    const t = roiTarget.value;
    if (/items/.test(t)) { roiRows.value = '12'; roiCols.value = '1'; }
    else if (/oils/.test(t)) { roiRows.value = '3'; roiCols.value = '1'; }
    else { roiRows.value = '1'; roiCols.value = '1'; }
    render();
  });
})();
*/


// Tab switching logic
const compendiumTab = document.getElementById('compendiumTab');
const simulationTab = document.getElementById('simulationTab');
const analysisTab = document.getElementById('analysisTab');
// importTab removed; set to null
const importTab = null;
const tabCompendium = document.getElementById('tabCompendium');
const tabAnalysis = document.getElementById('tabAnalysis');
const tabSimulation = document.getElementById('tabSimulation');

// Tab switching functionality
function showTab(tabName) {
  // Hide all tabs
  compendiumTab.style.display = 'none';
  analysisTab.style.display = 'none';
  simulationTab.style.display = 'none';
  
  // Reset all tab button styles
  tabCompendium.style.background = '#111';
  if (tabAnalysis) tabAnalysis.style.background = '#111';
  tabSimulation.style.background = '#111';
  
  // Show selected tab and highlight button
  if (tabName === 'compendium') {
    compendiumTab.style.display = 'flex';
    tabCompendium.style.background = '#300';
  } else if (tabName === 'analysis') {
    analysisTab.style.display = 'flex';
    tabAnalysis.style.background = '#320';
    renderAnalysis(); // Update analysis content
  } else if (tabName === 'simulation') {
    simulationTab.style.display = 'flex';  
    tabSimulation.style.background = '#030';
    updateSimulationPreview(); // Update simulation preview
  }
}

if (tabCompendium && tabAnalysis && tabSimulation) {
  tabCompendium.addEventListener('click', () => showTab('compendium'));
  tabAnalysis.addEventListener('click', () => showTab('analysis'));
  tabSimulation.addEventListener('click', () => showTab('simulation'));
  
  // Show compendium tab by default
  showTab('compendium');
}
if (showSimBtn && simulationTab && compendiumTab) {
  showSimBtn.addEventListener('click', () => showTab('simulation'));
}

// Render analysis content
function renderAnalysis() {
  renderPlayerAnalysis('P', 1);
  renderPlayerAnalysis('O', 2);
}

function renderPlayerAnalysis(sideKey, playerNum) {
  const side = sides[sideKey];
  const weaponEl = document.getElementById(`analysisP${playerNum}Weapon`);
  const edgeEl = document.getElementById(`analysisP${playerNum}Edge`);
  const itemsEl = document.getElementById(`analysisP${playerNum}Items`);
  
  // Render weapon
  if (side.weapon) {
    weaponEl.innerHTML = renderAnalysisItem(side.weapon, 'weapon');
  } else {
    weaponEl.innerHTML = '<div class="emptySlot">No weapon equipped</div>';
  }
  
  // Render edge
  if (side.edge) {
    const edgeData = RAW_DATA[side.edge];
    if (edgeData) {
      edgeEl.innerHTML = renderAnalysisItem(edgeData, 'edge');
    } else {
      edgeEl.innerHTML = '<div class="emptySlot">No edge selected</div>';
    }
  } else {
    edgeEl.innerHTML = '<div class="emptySlot">No edge selected</div>';
  }
  
  // Render items
  const equippedItems = side.items.filter(item => item !== null);
  if (equippedItems.length > 0) {
    itemsEl.innerHTML = equippedItems.map(item => renderAnalysisItem(item, 'item')).join('');
  } else {
    itemsEl.innerHTML = '<div class="emptySlot">No items equipped</div>';
  }
}

function renderAnalysisItem(item, type) {
  if (!item) return '';
  
  const iconPath = (item && item.key) ? `${item.key}/icon.png` : `${item.bucket}/${item.slug}/icon.png`;
  const stats = item.stats || {};
  const tags = item.tags || [];
  
  // Build stats display
  const statsHtml = ['attack', 'health', 'armor', 'speed']
    .map(stat => {
      const value = stats[stat] || 0;
      if (value === 0) return '';
      const icon = `assets/${stat === 'health' ? 'health' : stat}.png`;
      return `<div class="pill"><img src="${icon}" alt="${stat}"><span>${value}</span></div>`;
    })
    .filter(s => s)
    .join('');
    
  // Build tags display  
  const tagsHtml = tags.map(tag => `<span class="analysisTag">${tag}</span>`).join('');
  
  return `
    <div class="analysisItem ${type}">
      <div class="analysisItemHeader">
        <img src="${iconPath}" alt="${item.name}">
        <div class="analysisItemName">${item.name}</div>
      </div>
      <div class="analysisItemEffect">${item.effect || 'No effect description'}</div>
      <div class="analysisItemStats">${statsHtml}</div>
      ${tagsHtml ? `<div class="analysisItemTags">${tagsHtml}</div>` : ''}
    </div>
  `;
}

// Initial render happens after details.json loads via loadData()
</script>

</body>
</html>

